(window.webpackJsonp=window.webpackJsonp||[]).push([[239],{660:function(a,t,s){"use strict";s.r(t);var e=s(16),r=Object(e.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"pagespeed-规则和建议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pagespeed-规则和建议"}},[a._v("#")]),a._v(" PageSpeed 规则和建议")]),a._v(" "),s("p",[a._v("本指南审视 PageSpeed Insights 规则背景：优化关键渲染路径时的注意事项以及原因。")]),a._v(" "),s("h2",{attrs:{id:"消除阻塞渲染的-javascript-和-css"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消除阻塞渲染的-javascript-和-css"}},[a._v("#")]),a._v(" 消除阻塞渲染的 JavaScript 和 CSS")]),a._v(" "),s("p",[a._v("要以最快速度完成首次渲染，需要最大限度减少网页上关键资源的数量并（尽可能）消除这些资源，最大限度减少下载的关键字节数，以及优化关键路径长度。")]),a._v(" "),s("h2",{attrs:{id:"优化-javascript-的使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优化-javascript-的使用"}},[a._v("#")]),a._v(" 优化 JavaScript 的使用")]),a._v(" "),s("p",[a._v("默认情况下，JavaScript 资源会阻塞解析器，除非将其标记为 "),s("code",[a._v("async")]),a._v(" 或通过专门的 JavaScript 代码段进行添加。阻塞解析器的 JavaScript 会强制浏览器等待 CSSOM 并暂停 DOM 的构建，继而大大延迟首次渲染的时间。")]),a._v(" "),s("h3",{attrs:{id:"首选使用异步-javascript-资源"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#首选使用异步-javascript-资源"}},[a._v("#")]),a._v(" 首选使用异步 JavaScript 资源")]),a._v(" "),s("p",[a._v("异步资源不会阻塞文档解析器，让浏览器能够避免在执行脚本之前受阻于 CSSOM。通常，如果脚本可以使用 "),s("code",[a._v("async")]),a._v(" 属性，也就意味着它并非首次渲染所必需。可以考虑在首次渲染后异步加载脚本。")]),a._v(" "),s("h3",{attrs:{id:"避免同步服务器调用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#避免同步服务器调用"}},[a._v("#")]),a._v(" 避免同步服务器调用")]),a._v(" "),s("p",[a._v("使用 "),s("code",[a._v("navigator.sendBeacon()")]),a._v(" 方法来限制 XMLHttpRequests 在 "),s("code",[a._v("unload")]),a._v(" 处理程序中发送的数据。 因为许多浏览器都对此类请求有同步要求，所以可能减慢网页转换速度，有时还很明显。 以下代码展示了如何利用 "),s("code",[a._v("navigator.sendBeacon()")]),a._v(" 向 "),s("code",[a._v("pagehide")]),a._v(" 处理程序而不是 "),s("code",[a._v("unload")]),a._v(" 处理程序中的服务器发送数据。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("<script>\n  function() {\n    window.addEventListener('pagehide', logData, false);\n    function logData() {\n      navigator.sendBeacon(\n        'https://putsreq.herokuapp.com/Dt7t2QzUkG18aDTMMcop',\n        'Sent by a beacon!');\n    }\n  }();\n<\/script>\n")])])]),s("p",[a._v("新增的 "),s("code",[a._v("fetch()")]),a._v(" 方法提供了一种方便的数据异步请求方式。由于它尚未做到随处可用，因此您应该利用功能检测来测试其是否存在，然后再使用。该方法通过 Promise 而非多个事件处理程序来处理响应。不同于对 XMLHttpRequest 的响应，从 Chrome 43 开始，fetch 响应将是 stream 对象。这意味着调用 "),s("code",[a._v("json()")]),a._v(" 也会返回 Promise。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("<script>\nfetch('./api/some.json')\n  .then(\n    function(response) {\n      if (response.status !== 200) {\n        console.log('Looks like there was a problem. Status Code: ' +  response.status);\n        return;\n      }\n      // Examine the text in the response\n      response.json().then(function(data) {\n        console.log(data);\n      });\n    }\n  )\n  .catch(function(err) {\n    console.log('Fetch Error :-S', err);\n  });\n<\/script>\n")])])]),s("p",[s("code",[a._v("fetch()")]),a._v(" 方法也可处理 POST 请求。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("<script>\nfetch(url, {\n  method: 'post',\n  headers: {\n    \"Content-type\": \"application/x-www-form-urlencoded; charset=UTF-8\"\n  },\n  body: 'foo=bar&lorem=ipsum'\n}).then(function() { // Aditional code });\n<\/script>\n")])])]),s("h3",{attrs:{id:"延迟解析-javascript"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#延迟解析-javascript"}},[a._v("#")]),a._v(" 延迟解析 JavaScript")]),a._v(" "),s("p",[a._v("为了最大限度减少浏览器渲染网页的工作量，应延迟任何非必需的脚本（即对构建首次渲染的可见内容无关紧要的脚本）。")]),a._v(" "),s("h3",{attrs:{id:"避免运行时间长的-javascript"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#避免运行时间长的-javascript"}},[a._v("#")]),a._v(" 避免运行时间长的 JavaScript")]),a._v(" "),s("p",[a._v("运行时间长的 JavaScript 会阻止浏览器构建 DOM、CSSOM 以及渲染网页，所以任何对首次渲染无关紧要的初始化逻辑和功能都应延后执行。如果需要运行较长的初始化序列，请考虑将其拆分为若干阶段，以便浏览器可以间隔处理其他事件。")]),a._v(" "),s("h2",{attrs:{id:"优化-css-的使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优化-css-的使用"}},[a._v("#")]),a._v(" 优化 CSS 的使用")]),a._v(" "),s("p",[a._v("CSS 是构建渲染树的必备元素，首次构建网页时，JavaScript 常常受阻于 CSS。确保将任何非必需的 CSS 都标记为非关键资源（例如打印和其他媒体查询），并应确保尽可能减少关键 CSS 的数量，以及尽可能缩短传送时间。")]),a._v(" "),s("h3",{attrs:{id:"将-css-置于文档-head-标签内"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#将-css-置于文档-head-标签内"}},[a._v("#")]),a._v(" 将 CSS 置于文档 head 标签内")]),a._v(" "),s("p",[a._v("尽早在 HTML 文档内指定所有 CSS 资源，以便浏览器尽早发现 `` 标记并尽早发出 CSS 请求。")]),a._v(" "),s("h3",{attrs:{id:"避免使用-css-import"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#避免使用-css-import"}},[a._v("#")]),a._v(" 避免使用 CSS import")]),a._v(" "),s("p",[a._v("一个样式表可以使用 CSS import ("),s("code",[a._v("@import")]),a._v(") 指令从另一样式表文件导入规则。不过，应避免使用这些指令，因为它们会在关键路径中增加往返次数：只有在收到并解析完带有 "),s("code",[a._v("@import")]),a._v(" 规则的 CSS 样式表之后，才会发现导入的 CSS 资源。")]),a._v(" "),s("h3",{attrs:{id:"内联阻塞渲染的-css"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内联阻塞渲染的-css"}},[a._v("#")]),a._v(" 内联阻塞渲染的 CSS")]),a._v(" "),s("p",[a._v("为获得最佳性能，您可能会考虑将关键 CSS 直接内联到 HTML 文档内。这样做不会增加关键路径中的往返次数，并且如果实现得当，在只有 HTML 是阻塞渲染的资源时，可实现“一次往返”关键路径长度。")])])}),[],!1,null,null,null);t.default=r.exports}}]);