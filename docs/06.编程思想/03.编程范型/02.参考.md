---
title: 参考
date: 2020-12-31 21:09:38
permalink: /pages/9fb855/
categories:
  - 编程思想
  - 编程范型
tags:
  -
---

<!-- ::: run {title:"css3 伪元素",row:false,reverse:true}

```html
<template>
  <body>
    请输入数字：
    <input type="text" id="number1" />
    <input type="button" value="生成" id="btn" />
    <br />
    斐波那契数：
    <input type="text" id="number2" />
  </body>
</template>
<script>
  export default {
    mounted() {
      var number1 = document.getElementById("number1"); //获取元素
      var number2 = document.getElementById("number2");

      function fn(a) {
        //定义函数 用递归
        if (a <= 2) {
          //临界值设置
          return 1;
        } else {
          return fn(a - 1) + fn(a - 2); //调用自身
        }
      }
      btn.onclick = function() {
        //点击事件

        var num1 = number1.value; //获取元素
        //console.log(num1);
        var m = fn(num1);
        //console.log(m);
        number2.value = m; //写入文本框
      };
    },
  };
  window.onload = function() {};
</script>
```

::: -->

[JavaScript 写斐波那契数列的几种方式](https://blog.csdn.net/qq_39300332/article/details/80000837?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.control)

斐波那契数，指的是这样一个数列：1、1、2、3、5、8、13、21、34、55、……在数学上，斐波那契数列以如下被以递归的方法定义：F0=0，F1=1，Fn=Fn-1+Fn-2（n>=2，n∈N）。

$$
1+2+3+......+ n-1 + n
= (1+n)*n/2
= 0.5n^2 + 0.5n
$$

常用的计算斐波那契数列的方法分为两大类：递归和循环。

1. 递归（普通版）

   有重复计算的问题，如：当 n 为 5 的时候要计算 fibonacci(4) + fibonacci(3)，当 n 为 4 的要计算 fibonacci(3) + fibonacci(2) ，这时 fibonacci(3)就是重复计算了。所以最终结果会最后执行，可以理解为先进后出。

   时间复杂度：

   $$
   T(n)= 0.5n^2 + 0.5n
   $$

   ::: run {title:"1、递归（普通版）",row:false,reverse:true}

   ```html
   <template>
     <div>
       <div>结果：{{ result }}</div>
       <div>调用函数次数：{{ total }}</div>
     </div>
   </template>
   <script>
     export default {
       data() {
         return {
           result: null,
           total: 0,
         };
       },
       methods: {
         fibonacci(n) {
           this.total = this.total + 1;
           if (n == 1 || n == 2) {
             return 1;
           }
           return this.fibonacci(n - 2) + this.fibonacci(n - 1);
         },
       },
       mounted() {
         this.result = this.fibonacci(20);
       },
     };
   </script>
   ```

   :::

   代码最少也容易理解，但是当 n 较大时很快产生栈溢出，引发原因是“调用帧”过多。

   什么是调用帧？

   参考：[尾调用优化](/pages/ed309d/#尾调用优化-2)

   函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。

   函数内部调用函数，就形成一个“调用栈”（call stack）：

   - 在`A`的调用帧上方，还会形成一个`B`的调用帧。

   - 等到`B`运行结束，将结果返回到`A`，`B`的调用帧才会消失。

2. 递归（优化版）

   “尾调用优化”（Tail call optimization）：即只保留内层函数的调用帧（不再保存调用位置和内部变量等信息）。

   如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。

   ::: run {title:"2、递归（优化版）",row:false,reverse:true}

   ```html
   <template>
     <div>
       <div>结果：{{ result }}</div>
       <div>调用函数次数：{{ total }}</div>
     </div>
   </template>
   <script>
     export default {
       data() {
         return {
           result: null,
           total: 0,
         };
       },
       methods: {
         fibonacci(n, ac1 = 1, ac2 = 1) {
           this.total = this.total + 1;
           if (n <= 1) {
             return ac2;
           }
           return this.fibonacci(n - 1, ac2, ac1 + ac2);
         },
       },
       mounted() {
         this.result = this.fibonacci(20);
       },
     };
   </script>
   ```

   :::

   此方式是函数尾调用优化之后的写法（默认参数 ES6 及以后版本支持，ES5 请使用常规默认值写法），理解上稍微复杂，但是不会发生栈溢出，推荐使用。

3. 循环版

   循环版本最好理解，就是给初始值，然后不断的累加即可(用了解构赋值，代码更简洁)。

   ::: run {title:"3、循环版",row:false,reverse:true}

   ```html
   <template>
     <div>
       <div>结果：{{ result }}</div>
       <div>调用函数次数：{{ total }}</div>
     </div>
   </template>
   <script>
     export default {
       data() {
         return {
           result: null,
           total: 0,
         };
       },
       methods: {
         fibonacci(n) {
           this.total = this.total + 1;
           if (n === 1 || n === 2) {
             return 1;
           }
           let ac1 = 1,
             ac2 = 1;
           for (let i = 2; i < n; i++) {
             [ac1, ac2] = [ac2, ac1 + ac2];
           }
           return ac2;
         },
       },
       mounted() {
         this.result = this.fibonacci(20);
       },
     };
   </script>
   ```

   :::

4. generator 版

::: run {title:"4、generator 版",row:false,reverse:true}

```html
<template>
  <div>
    <div>结果：{{ result }}</div>
    <div>调用函数次数：{{ total }}</div>
  </div>
</template>
<script>
  export default {
    data() {
      return {
        result: null,
        total: 0,
      };
    },
    methods: {
      *fibonacci(num) {
        console.log(1111);
        // let [pre, current] = [0, 1];
        // for (let i = 0; i < num; i++) {
        //   yield current;
        //   [pre, current] = [current, pre + current];
        // }
      },
    },
    mounted() {
      let myFib = this.fibonacci(10);
      console.log(2222);
      for (let fib of myFib) {
        console.log(fib);
      }
    },
  };
</script>
```

:::

<!-- ::: run {title:"css3 伪元素",row:false,reverse:true}

```html
<template>
  <div>结果：{{ result }}</div>
</template>
<script>
  export default {
    data() {
      return {
        result: null,
      };
    },
    mounted() {
      var memoizer = function(func) {
        let memo = [];
        return function(n) {
          if (memo[n] == undefined) {
            memo[n] = func(n);
            console.log("memoizer", memo[n]);
          }
          return memo[n];
        };
      };
      var fibonacci = memoizer(function(n) {
        console.log("fibonacci", n);
        if (n == 1 || n == 2) {
          return 1;
        }
        return fibonacci(n - 2) + fibonacci(n - 1);
      });
      this.result = fibonacci(30);
    },
  };
</script>
```

::: -->

## 未整理
