<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>第6章 面向对象的程序设计 | LiYang&#39;s blog</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/2.10.0/github-markdown.min.css">
    <meta name="description" content="web前端技术博客,简洁至上,专注web前端学习与总结。JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github等技术文章。">
    <link rel="preload" href="/assets/css/0.styles.ff3929f5.css" as="style"><link rel="preload" href="/assets/js/app.40794b05.js" as="script"><link rel="preload" href="/assets/js/2.21c2c3d2.js" as="script"><link rel="preload" href="/assets/js/182.e1193960.js" as="script"><link rel="prefetch" href="/assets/js/10.058f7072.js"><link rel="prefetch" href="/assets/js/100.f3568421.js"><link rel="prefetch" href="/assets/js/101.3669cd11.js"><link rel="prefetch" href="/assets/js/102.cefa1450.js"><link rel="prefetch" href="/assets/js/103.0fc12baa.js"><link rel="prefetch" href="/assets/js/104.fc75b27c.js"><link rel="prefetch" href="/assets/js/105.9efa40da.js"><link rel="prefetch" href="/assets/js/106.2132845c.js"><link rel="prefetch" href="/assets/js/107.50efbf3f.js"><link rel="prefetch" href="/assets/js/108.2e4d6b56.js"><link rel="prefetch" href="/assets/js/109.362f4964.js"><link rel="prefetch" href="/assets/js/11.acbb83b6.js"><link rel="prefetch" href="/assets/js/110.260ecf9d.js"><link rel="prefetch" href="/assets/js/111.ac0ed6b0.js"><link rel="prefetch" href="/assets/js/112.e26ce83f.js"><link rel="prefetch" href="/assets/js/113.c17594f4.js"><link rel="prefetch" href="/assets/js/114.081ea0e8.js"><link rel="prefetch" href="/assets/js/115.9f1c1fc5.js"><link rel="prefetch" href="/assets/js/116.300e5c32.js"><link rel="prefetch" href="/assets/js/117.005796a9.js"><link rel="prefetch" href="/assets/js/118.5dd34410.js"><link rel="prefetch" href="/assets/js/119.2a52edee.js"><link rel="prefetch" href="/assets/js/12.f5d0a92b.js"><link rel="prefetch" href="/assets/js/120.2692504f.js"><link rel="prefetch" href="/assets/js/121.de91fbab.js"><link rel="prefetch" href="/assets/js/122.8fe54cb7.js"><link rel="prefetch" href="/assets/js/123.27f7de3d.js"><link rel="prefetch" href="/assets/js/124.df486141.js"><link rel="prefetch" href="/assets/js/125.b3333a19.js"><link rel="prefetch" href="/assets/js/126.0252235d.js"><link rel="prefetch" href="/assets/js/127.e416e0cb.js"><link rel="prefetch" href="/assets/js/128.80fc9ce8.js"><link rel="prefetch" href="/assets/js/129.d549459c.js"><link rel="prefetch" href="/assets/js/13.c75b92e4.js"><link rel="prefetch" href="/assets/js/130.535fd734.js"><link rel="prefetch" href="/assets/js/131.9d165e98.js"><link rel="prefetch" href="/assets/js/132.ef795834.js"><link rel="prefetch" href="/assets/js/133.2044b8d2.js"><link rel="prefetch" href="/assets/js/134.ea0aee7d.js"><link rel="prefetch" href="/assets/js/135.6f39d3e5.js"><link rel="prefetch" href="/assets/js/136.47dc0812.js"><link rel="prefetch" href="/assets/js/137.3eaf9788.js"><link rel="prefetch" href="/assets/js/138.1135d0ed.js"><link rel="prefetch" href="/assets/js/139.d546d7cb.js"><link rel="prefetch" href="/assets/js/14.1114043e.js"><link rel="prefetch" href="/assets/js/140.aae58cac.js"><link rel="prefetch" href="/assets/js/141.b8b72927.js"><link rel="prefetch" href="/assets/js/142.b161cba1.js"><link rel="prefetch" href="/assets/js/143.cfb7b204.js"><link rel="prefetch" href="/assets/js/144.818c2cff.js"><link rel="prefetch" href="/assets/js/145.60f90c39.js"><link rel="prefetch" href="/assets/js/146.7ddef663.js"><link rel="prefetch" href="/assets/js/147.06d1017e.js"><link rel="prefetch" href="/assets/js/148.c7c411a0.js"><link rel="prefetch" href="/assets/js/149.334bd804.js"><link rel="prefetch" href="/assets/js/15.3f0b462f.js"><link rel="prefetch" href="/assets/js/150.7c8c73b7.js"><link rel="prefetch" href="/assets/js/151.62d10d6c.js"><link rel="prefetch" href="/assets/js/152.82e28168.js"><link rel="prefetch" href="/assets/js/153.e1ee4321.js"><link rel="prefetch" href="/assets/js/154.f576cc10.js"><link rel="prefetch" href="/assets/js/155.964a90f2.js"><link rel="prefetch" href="/assets/js/156.4bdc75f5.js"><link rel="prefetch" href="/assets/js/157.6581cb30.js"><link rel="prefetch" href="/assets/js/158.24f9817a.js"><link rel="prefetch" href="/assets/js/159.89915418.js"><link rel="prefetch" href="/assets/js/16.d8001a48.js"><link rel="prefetch" href="/assets/js/160.643f5b36.js"><link rel="prefetch" href="/assets/js/161.4714f73e.js"><link rel="prefetch" href="/assets/js/162.7527446c.js"><link rel="prefetch" href="/assets/js/163.229f891d.js"><link rel="prefetch" href="/assets/js/164.429d3070.js"><link rel="prefetch" href="/assets/js/165.5e342261.js"><link rel="prefetch" href="/assets/js/166.f0cb088a.js"><link rel="prefetch" href="/assets/js/167.40a0038b.js"><link rel="prefetch" href="/assets/js/168.758c8238.js"><link rel="prefetch" href="/assets/js/169.a972a570.js"><link rel="prefetch" href="/assets/js/17.8a850ded.js"><link rel="prefetch" href="/assets/js/170.0fba2db3.js"><link rel="prefetch" href="/assets/js/171.43f66f94.js"><link rel="prefetch" href="/assets/js/172.9467deb8.js"><link rel="prefetch" href="/assets/js/173.26fef872.js"><link rel="prefetch" href="/assets/js/174.0958a150.js"><link rel="prefetch" href="/assets/js/175.a87b0ab5.js"><link rel="prefetch" href="/assets/js/176.04363b06.js"><link rel="prefetch" href="/assets/js/177.34672e1c.js"><link rel="prefetch" href="/assets/js/178.42e0456b.js"><link rel="prefetch" href="/assets/js/179.ec648519.js"><link rel="prefetch" href="/assets/js/18.fe4d545b.js"><link rel="prefetch" href="/assets/js/180.8a5fc825.js"><link rel="prefetch" href="/assets/js/181.3dabf704.js"><link rel="prefetch" href="/assets/js/183.975cb0ee.js"><link rel="prefetch" href="/assets/js/184.a0e65b8e.js"><link rel="prefetch" href="/assets/js/185.1b24284f.js"><link rel="prefetch" href="/assets/js/186.9f5186d0.js"><link rel="prefetch" href="/assets/js/187.7b2b6fb4.js"><link rel="prefetch" href="/assets/js/188.39449f6c.js"><link rel="prefetch" href="/assets/js/189.d6c034d8.js"><link rel="prefetch" href="/assets/js/19.48cc10f6.js"><link rel="prefetch" href="/assets/js/190.2fe5508a.js"><link rel="prefetch" href="/assets/js/191.368805e9.js"><link rel="prefetch" href="/assets/js/192.8351a6ec.js"><link rel="prefetch" href="/assets/js/193.4d86bf98.js"><link rel="prefetch" href="/assets/js/194.86d3a829.js"><link rel="prefetch" href="/assets/js/195.931ce7ef.js"><link rel="prefetch" href="/assets/js/196.35818a22.js"><link rel="prefetch" href="/assets/js/197.109eef6d.js"><link rel="prefetch" href="/assets/js/198.a092c6d3.js"><link rel="prefetch" href="/assets/js/199.0a7aea6b.js"><link rel="prefetch" href="/assets/js/20.1baf39d0.js"><link rel="prefetch" href="/assets/js/200.eb75a43c.js"><link rel="prefetch" href="/assets/js/201.167f1a27.js"><link rel="prefetch" href="/assets/js/202.80380232.js"><link rel="prefetch" href="/assets/js/203.dfb07860.js"><link rel="prefetch" href="/assets/js/204.0de5d7ad.js"><link rel="prefetch" href="/assets/js/205.da83ee83.js"><link rel="prefetch" href="/assets/js/206.4ff75723.js"><link rel="prefetch" href="/assets/js/207.c0023a8f.js"><link rel="prefetch" href="/assets/js/208.e1d257d1.js"><link rel="prefetch" href="/assets/js/209.668018f6.js"><link rel="prefetch" href="/assets/js/21.b0e0d339.js"><link rel="prefetch" href="/assets/js/210.eac594b9.js"><link rel="prefetch" href="/assets/js/211.1cc3154f.js"><link rel="prefetch" href="/assets/js/212.0a3e0704.js"><link rel="prefetch" href="/assets/js/213.e5257a7e.js"><link rel="prefetch" href="/assets/js/214.a335e108.js"><link rel="prefetch" href="/assets/js/215.0422f8a3.js"><link rel="prefetch" href="/assets/js/216.6e63fc29.js"><link rel="prefetch" href="/assets/js/217.a38e1ca8.js"><link rel="prefetch" href="/assets/js/218.04c38c96.js"><link rel="prefetch" href="/assets/js/219.89a7899f.js"><link rel="prefetch" href="/assets/js/22.f5c6b71f.js"><link rel="prefetch" href="/assets/js/220.02a01cb8.js"><link rel="prefetch" href="/assets/js/221.e0eded2d.js"><link rel="prefetch" href="/assets/js/222.06c16e31.js"><link rel="prefetch" href="/assets/js/223.a4b75ccb.js"><link rel="prefetch" href="/assets/js/224.9129f3cf.js"><link rel="prefetch" href="/assets/js/225.1c089563.js"><link rel="prefetch" href="/assets/js/226.8d7ae032.js"><link rel="prefetch" href="/assets/js/227.3bfa4328.js"><link rel="prefetch" href="/assets/js/228.a1748bdf.js"><link rel="prefetch" href="/assets/js/229.c1c27996.js"><link rel="prefetch" href="/assets/js/23.265953eb.js"><link rel="prefetch" href="/assets/js/230.f39a1f48.js"><link rel="prefetch" href="/assets/js/231.ca132071.js"><link rel="prefetch" href="/assets/js/232.9ca5e931.js"><link rel="prefetch" href="/assets/js/233.e04e254f.js"><link rel="prefetch" href="/assets/js/234.22381aab.js"><link rel="prefetch" href="/assets/js/235.6bc8508d.js"><link rel="prefetch" href="/assets/js/236.5914c9a6.js"><link rel="prefetch" href="/assets/js/237.a721ad82.js"><link rel="prefetch" href="/assets/js/238.af3e025d.js"><link rel="prefetch" href="/assets/js/239.44fe29c9.js"><link rel="prefetch" href="/assets/js/24.16fb3de9.js"><link rel="prefetch" href="/assets/js/240.9ba57538.js"><link rel="prefetch" href="/assets/js/241.46a9cb7e.js"><link rel="prefetch" href="/assets/js/242.ae70539b.js"><link rel="prefetch" href="/assets/js/243.8a1feaf8.js"><link rel="prefetch" href="/assets/js/244.cdbaaca6.js"><link rel="prefetch" href="/assets/js/245.7117eda6.js"><link rel="prefetch" href="/assets/js/246.742dd686.js"><link rel="prefetch" href="/assets/js/247.7046d3e0.js"><link rel="prefetch" href="/assets/js/248.dbd8407d.js"><link rel="prefetch" href="/assets/js/249.206b660b.js"><link rel="prefetch" href="/assets/js/25.21d0c0dd.js"><link rel="prefetch" href="/assets/js/250.f559b400.js"><link rel="prefetch" href="/assets/js/251.f13bd91c.js"><link rel="prefetch" href="/assets/js/252.aaa10b65.js"><link rel="prefetch" href="/assets/js/253.78640ae7.js"><link rel="prefetch" href="/assets/js/254.5251f555.js"><link rel="prefetch" href="/assets/js/255.5f8655e1.js"><link rel="prefetch" href="/assets/js/256.0b1da59b.js"><link rel="prefetch" href="/assets/js/257.c4b311d3.js"><link rel="prefetch" href="/assets/js/258.62c44f28.js"><link rel="prefetch" href="/assets/js/259.7a8ecb77.js"><link rel="prefetch" href="/assets/js/26.68bfb3cd.js"><link rel="prefetch" href="/assets/js/260.9506bc77.js"><link rel="prefetch" href="/assets/js/261.ab6ac9b0.js"><link rel="prefetch" href="/assets/js/262.6f237036.js"><link rel="prefetch" href="/assets/js/27.e08c2734.js"><link rel="prefetch" href="/assets/js/28.d05f086f.js"><link rel="prefetch" href="/assets/js/29.14bacba0.js"><link rel="prefetch" href="/assets/js/3.9859aeed.js"><link rel="prefetch" href="/assets/js/30.d1c1c795.js"><link rel="prefetch" href="/assets/js/31.c464fa16.js"><link rel="prefetch" href="/assets/js/32.74ae82b3.js"><link rel="prefetch" href="/assets/js/33.6d39a197.js"><link rel="prefetch" href="/assets/js/34.a5448e75.js"><link rel="prefetch" href="/assets/js/35.e677db99.js"><link rel="prefetch" href="/assets/js/36.9373382d.js"><link rel="prefetch" href="/assets/js/37.aaef6158.js"><link rel="prefetch" href="/assets/js/38.b8534a41.js"><link rel="prefetch" href="/assets/js/39.8e5ecefa.js"><link rel="prefetch" href="/assets/js/4.b3a2afa1.js"><link rel="prefetch" href="/assets/js/40.0fbf1e24.js"><link rel="prefetch" href="/assets/js/41.b68829b1.js"><link rel="prefetch" href="/assets/js/42.c6327e05.js"><link rel="prefetch" href="/assets/js/43.5cdcb8f5.js"><link rel="prefetch" href="/assets/js/44.48fd0994.js"><link rel="prefetch" href="/assets/js/45.45e8d731.js"><link rel="prefetch" href="/assets/js/46.ea182d63.js"><link rel="prefetch" href="/assets/js/47.3d1bf5d3.js"><link rel="prefetch" href="/assets/js/48.485f3e01.js"><link rel="prefetch" href="/assets/js/49.a2622af2.js"><link rel="prefetch" href="/assets/js/5.ddbdceff.js"><link rel="prefetch" href="/assets/js/50.572052eb.js"><link rel="prefetch" href="/assets/js/51.ed257c0f.js"><link rel="prefetch" href="/assets/js/52.23b18f3a.js"><link rel="prefetch" href="/assets/js/53.14b56cb4.js"><link rel="prefetch" href="/assets/js/54.bb07175e.js"><link rel="prefetch" href="/assets/js/55.d48bde66.js"><link rel="prefetch" href="/assets/js/56.38433979.js"><link rel="prefetch" href="/assets/js/57.99b13154.js"><link rel="prefetch" href="/assets/js/58.498c71ad.js"><link rel="prefetch" href="/assets/js/59.24e06284.js"><link rel="prefetch" href="/assets/js/6.cae33779.js"><link rel="prefetch" href="/assets/js/60.fe0260d5.js"><link rel="prefetch" href="/assets/js/61.b5bcfd89.js"><link rel="prefetch" href="/assets/js/62.bdc41a00.js"><link rel="prefetch" href="/assets/js/63.10468463.js"><link rel="prefetch" href="/assets/js/64.028e0281.js"><link rel="prefetch" href="/assets/js/65.f762d4ff.js"><link rel="prefetch" href="/assets/js/66.33239ba5.js"><link rel="prefetch" href="/assets/js/67.c89232f4.js"><link rel="prefetch" href="/assets/js/68.e2ab181e.js"><link rel="prefetch" href="/assets/js/69.86594af5.js"><link rel="prefetch" href="/assets/js/7.5bd7e1fe.js"><link rel="prefetch" href="/assets/js/70.f79bf73b.js"><link rel="prefetch" href="/assets/js/71.36d10bfe.js"><link rel="prefetch" href="/assets/js/72.85d3c063.js"><link rel="prefetch" href="/assets/js/73.4746e647.js"><link rel="prefetch" href="/assets/js/74.c8d81312.js"><link rel="prefetch" href="/assets/js/75.dd1ae94f.js"><link rel="prefetch" href="/assets/js/76.b06cc20c.js"><link rel="prefetch" href="/assets/js/77.855f7650.js"><link rel="prefetch" href="/assets/js/78.4e5b0253.js"><link rel="prefetch" href="/assets/js/79.95567ab3.js"><link rel="prefetch" href="/assets/js/8.62836d81.js"><link rel="prefetch" href="/assets/js/80.7b7033a0.js"><link rel="prefetch" href="/assets/js/81.45b93100.js"><link rel="prefetch" href="/assets/js/82.36d8eb8a.js"><link rel="prefetch" href="/assets/js/83.b361b85d.js"><link rel="prefetch" href="/assets/js/84.2e4874fa.js"><link rel="prefetch" href="/assets/js/85.272cfc57.js"><link rel="prefetch" href="/assets/js/86.aaa56439.js"><link rel="prefetch" href="/assets/js/87.dc9e3259.js"><link rel="prefetch" href="/assets/js/88.689b6a8b.js"><link rel="prefetch" href="/assets/js/89.f22e017d.js"><link rel="prefetch" href="/assets/js/9.584f1ef6.js"><link rel="prefetch" href="/assets/js/90.d0ed3f12.js"><link rel="prefetch" href="/assets/js/91.21868b2f.js"><link rel="prefetch" href="/assets/js/92.0b1bc56b.js"><link rel="prefetch" href="/assets/js/93.9fd7ccef.js"><link rel="prefetch" href="/assets/js/94.5cee5367.js"><link rel="prefetch" href="/assets/js/95.c81773d8.js"><link rel="prefetch" href="/assets/js/96.c8f61d95.js"><link rel="prefetch" href="/assets/js/97.f86ea530.js"><link rel="prefetch" href="/assets/js/98.09c0fa30.js"><link rel="prefetch" href="/assets/js/99.c4bd6444.js">
    <link rel="stylesheet" href="/assets/css/0.styles.ff3929f5.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.svg" alt="LiYang's blog" class="logo"> <span class="site-name can-hide">LiYang's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/categories/" class="nav-link">分类</a></div><div class="nav-item"><a href="/tags/" class="nav-link">标签</a></div><div class="nav-item"><a href="/archives/" class="nav-link">归档</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><a href="/pages/0a6679/" class="link-title">前端</a> <span class="title" style="display:none;">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/0a6679/" class="nav-link">编程基础</a></li><li class="dropdown-item"><!----> <a href="/pages/714859/" class="nav-link">开发软件</a></li><li class="dropdown-item"><!----> <a href="/pages/690ae0/" class="nav-link">类库框架</a></li><li class="dropdown-item"><!----> <a href="/pages/d2dd63/" class="nav-link">知识进阶</a></li><li class="dropdown-item"><!----> <a href="/pages/fd695e/" class="nav-link">工程开发</a></li><li class="dropdown-item"><!----> <a href="/pages/f37132/" class="nav-link">编程思想</a></li><li class="dropdown-item"><!----> <a href="/pages/73d90e/" class="nav-link">领域分支</a></li><li class="dropdown-item"><!----> <a href="/pages/b7eb61/" class="nav-link">社区发展</a></li><li class="dropdown-item"><!----> <a href="/pages/83b440/" class="nav-link">计算机基础</a></li><li class="dropdown-item"><!----> <a href="/pages/0d54d7/" class="nav-link">后端知识</a></li><li class="dropdown-item"><!----> <a href="/pages/416bc0/" class="nav-link">软技能</a></li></ul></div></div><div class="nav-item"><a href="/leetCode/" class="nav-link">🤡LeetCode</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="笔记本" class="dropdown-title"><a href="/notes/" class="link-title">笔记本</a> <span class="title" style="display:none;">笔记本</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>书籍</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/books/es6/" class="nav-link">《ES6教程》</a></li><li class="dropdown-subitem"><a href="/books/professionalJs/" class="nav-link">《JavaScript高级程序设计》</a></li></ul></li><li class="dropdown-item"><h4>教程</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/course/css3-jspang/" class="nav-link">CSS3(技术胖)</a></li><li class="dropdown-subitem"><a href="/course/es6-jspang/" class="nav-link">ES6(技术胖)</a></li><li class="dropdown-subitem"><a href="/course/performance/" class="nav-link">性能(Google Developers)</a></li></ul></li><li class="dropdown-item"><h4>技术文档</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/1b466b/.html" class="nav-link">leaflet中文教程</a></li></ul></li></ul></div></div> <a href="https://github.com/fineliving" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg"> <div class="blogger-info"><h3>Evan Xu</h3> <span>前端界的小学生</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/categories/" class="nav-link">分类</a></div><div class="nav-item"><a href="/tags/" class="nav-link">标签</a></div><div class="nav-item"><a href="/archives/" class="nav-link">归档</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><a href="/pages/0a6679/" class="link-title">前端</a> <span class="title" style="display:none;">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/0a6679/" class="nav-link">编程基础</a></li><li class="dropdown-item"><!----> <a href="/pages/714859/" class="nav-link">开发软件</a></li><li class="dropdown-item"><!----> <a href="/pages/690ae0/" class="nav-link">类库框架</a></li><li class="dropdown-item"><!----> <a href="/pages/d2dd63/" class="nav-link">知识进阶</a></li><li class="dropdown-item"><!----> <a href="/pages/fd695e/" class="nav-link">工程开发</a></li><li class="dropdown-item"><!----> <a href="/pages/f37132/" class="nav-link">编程思想</a></li><li class="dropdown-item"><!----> <a href="/pages/73d90e/" class="nav-link">领域分支</a></li><li class="dropdown-item"><!----> <a href="/pages/b7eb61/" class="nav-link">社区发展</a></li><li class="dropdown-item"><!----> <a href="/pages/83b440/" class="nav-link">计算机基础</a></li><li class="dropdown-item"><!----> <a href="/pages/0d54d7/" class="nav-link">后端知识</a></li><li class="dropdown-item"><!----> <a href="/pages/416bc0/" class="nav-link">软技能</a></li></ul></div></div><div class="nav-item"><a href="/leetCode/" class="nav-link">🤡LeetCode</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="笔记本" class="dropdown-title"><a href="/notes/" class="link-title">笔记本</a> <span class="title" style="display:none;">笔记本</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>书籍</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/books/es6/" class="nav-link">《ES6教程》</a></li><li class="dropdown-subitem"><a href="/books/professionalJs/" class="nav-link">《JavaScript高级程序设计》</a></li></ul></li><li class="dropdown-item"><h4>教程</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/course/css3-jspang/" class="nav-link">CSS3(技术胖)</a></li><li class="dropdown-subitem"><a href="/course/es6-jspang/" class="nav-link">ES6(技术胖)</a></li><li class="dropdown-subitem"><a href="/course/performance/" class="nav-link">性能(Google Developers)</a></li></ul></li><li class="dropdown-item"><h4>技术文档</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/1b466b/.html" class="nav-link">leaflet中文教程</a></li></ul></li></ul></div></div> <a href="https://github.com/fineliving" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/pages/62e671/" class="sidebar-link">什么是JavaScript</a></li><li><a href="/pages/ba2d08/" class="sidebar-link">HTML中的JavaScript</a></li><li><a href="/pages/14fe49/" class="sidebar-link">第3章 基本概念</a></li><li><a href="/pages/6906b5/" class="sidebar-link">第4章 变量、作用域和内存问题</a></li><li><a href="/pages/a7e35f/" class="sidebar-link">第5章 引用类型</a></li><li><a href="/pages/1b466b/" aria-current="page" class="active sidebar-link">第6章 面向对象的程序设计</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/1b466b/#_6-1-理解对象" class="sidebar-link">6.1 理解对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/1b466b/#_6-1-1-属性类型" class="sidebar-link">6.1.1 属性类型</a></li><li class="sidebar-sub-header"><a href="/pages/1b466b/#_6-1-2-定义多个属性" class="sidebar-link">6.1.2 定义多个属性</a></li><li class="sidebar-sub-header"><a href="/pages/1b466b/#_6-1-3-读取属性的特性" class="sidebar-link">6.1.3 读取属性的特性</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/1b466b/#_6-2-创建对象" class="sidebar-link">6.2 创建对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/1b466b/#_6-2-1-工厂模式" class="sidebar-link">6.2.1 工厂模式</a></li><li class="sidebar-sub-header"><a href="/pages/1b466b/#_6-2-2-构造函数模式" class="sidebar-link">6.2.2 构造函数模式</a></li><li class="sidebar-sub-header"><a href="/pages/1b466b/#_6-2-3-原型模式" class="sidebar-link">6.2.3 原型模式</a></li><li class="sidebar-sub-header"><a href="/pages/1b466b/#_6-2-4-组合使用构造函数模式和原型模式" class="sidebar-link">6.2.4 组合使用构造函数模式和原型模式</a></li><li class="sidebar-sub-header"><a href="/pages/1b466b/#_6-2-5-动态原型模式" class="sidebar-link">6.2.5 动态原型模式</a></li><li class="sidebar-sub-header"><a href="/pages/1b466b/#_6-2-6-寄生构造函数模式" class="sidebar-link">6.2.6 寄生构造函数模式</a></li><li class="sidebar-sub-header"><a href="/pages/1b466b/#_6-2-7-稳妥构造函数模式" class="sidebar-link">6.2.7 稳妥构造函数模式</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/1b466b/#_6-3-继承" class="sidebar-link">6.3 继承</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/1b466b/#_6-3-1-原型链" class="sidebar-link">6.3.1 原型链</a></li><li class="sidebar-sub-header"><a href="/pages/1b466b/#_6-3-2-借用构造函数" class="sidebar-link">6.3.2 借用构造函数</a></li><li class="sidebar-sub-header"><a href="/pages/1b466b/#_6-3-3-组合继承" class="sidebar-link">6.3.3 组合继承</a></li><li class="sidebar-sub-header"><a href="/pages/1b466b/#_6-3-4-原型式继承" class="sidebar-link">6.3.4 原型式继承</a></li><li class="sidebar-sub-header"><a href="/pages/1b466b/#_6-3-5-寄生式继承" class="sidebar-link">6.3.5 寄生式继承</a></li><li class="sidebar-sub-header"><a href="/pages/1b466b/#_6-3-6-寄生组合式继承" class="sidebar-link">6.3.6 寄生组合式继承</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/1b466b/#_6-4-小结" class="sidebar-link">6.4 小结</a></li></ul></li><li><a href="/pages/0e90f4/" class="sidebar-link">第7章 函数表达式</a></li><li><a href="/pages/df56f8/" class="sidebar-link">第8章 BOM</a></li><li><a href="/pages/ca56db/" class="sidebar-link">第9章 客户端检测</a></li><li><a href="/pages/db0f5b/" class="sidebar-link">第10章 DOM</a></li><li><a href="/pages/8c8da2/" class="sidebar-link">第11章 DOM扩展</a></li><li><a href="/pages/54f651/" class="sidebar-link">第12章 DOM2和DOM3</a></li><li><a href="/pages/cecea8/" class="sidebar-link">第13章 事件</a></li><li><a href="/pages/a963d6/" class="sidebar-link">第14章 表单脚本</a></li><li><a href="/pages/a18149/" class="sidebar-link">第15章 使用Canvas绘图</a></li><li><a href="/pages/97ea51/" class="sidebar-link">第16章 HTML5脚本编程</a></li><li><a href="/pages/9f231d/" class="sidebar-link">第17章 错误处理与调试</a></li><li><a href="/pages/afa7f3/" class="sidebar-link">第18章 JavaScript与XML</a></li><li><a href="/pages/aeeb57/" class="sidebar-link">第19章 E4X</a></li><li><a href="/pages/5a1ef0/" class="sidebar-link">第20章 JSON</a></li><li><a href="/pages/731b29/" class="sidebar-link">第21章 Ajax与Comet</a></li><li><a href="/pages/1e17b2/" class="sidebar-link">第22章 高级技巧</a></li><li><a href="/pages/f25c7c/" class="sidebar-link">第23章 离线应用与客户端存储</a></li><li><a href="/pages/fc4c20/" class="sidebar-link">第24章 最佳实践</a></li><li><a href="/pages/16e70e/" class="sidebar-link">第25章 新兴的API</a></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-1cd794fe><div class="articleInfo" data-v-1cd794fe><ul class="breadcrumbs" data-v-1cd794fe><li data-v-1cd794fe><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-1cd794fe></a></li> <li data-v-1cd794fe><a href="/books/professionalJs" title="《JavaScript高级程序设计》-目录页" data-v-1cd794fe>《JavaScript高级程序设计》</a></li> <!----> <!----></ul> <div class="info" data-v-1cd794fe><div title="作者" class="author iconfont icon-touxiang" data-v-1cd794fe><a href="https://github.com/fineliving" target="_blank" title="作者" class="beLink" data-v-1cd794fe>Li Yang</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-1cd794fe><a href="javascript:;" data-v-1cd794fe>2020-11-20</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">
          第6章 面向对象的程序设计
        </h1> <!----> <div class="theme-vdoing-content content__default"><h1 id="第-6-章-面向对象的程序设计"><a href="#第-6-章-面向对象的程序设计" class="header-anchor">#</a> 第 6 章 面向对象的程序设计</h1> <p><strong><em>1. 本章内容</em></strong></p> <ul><li>理解对象属性</li> <li>理解并创建对象</li> <li>理解继承</li></ul> <p><strong><em>2. 对象与引用类型</em></strong></p> <p>面向对象（Object-Oriented，OO）的语言有一个标志，那就是它们都有类的概念，而通过类可以创建任意多个具有相同属性和方法的对象。ECMAScript 中<strong>没有类</strong>的概念，因此它的对象也与基于类的语言中的对象有所不同。</p> <p>ECMA-262 把<strong>对象</strong>定义为：<strong>“无序属性的集合，其属性可以包含基本值、对象或者函数。”<strong>严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。正因为这样（以及其他将要讨论的原因），我们可以把 ECMAScript 的对象想象成</strong>散列表</strong>：无非就是一组名值对，其中值可以是数据或函数。</p> <p>每个<strong>对象</strong>都是基于一个<strong>引用类型</strong>创建的，这个引用类型：</p> <ul><li>可以是第 5 章讨论的<strong>原生类型</strong></li> <li>可以是开发人员<strong>定义的类型</strong></li></ul> <h2 id="_6-1-理解对象"><a href="#_6-1-理解对象" class="header-anchor">#</a> 6.1 理解对象</h2> <p><strong><em>1. 理解对象</em></strong></p> <p>创建自定义对象：</p> <ul><li><p>最简单方式就是创建一个 Object 的实例，然后再为它添加属性和方法。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
person<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">;</span>
person<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">29</span><span class="token punctuation">;</span>
person<span class="token punctuation">.</span>job <span class="token operator">=</span> <span class="token string">&quot;Software Engineer&quot;</span><span class="token punctuation">;</span>

person<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>对象字面量成为创建这种对象的首选模式。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token number">29</span><span class="token punctuation">,</span>
  job<span class="token operator">:</span> <span class="token string">&quot;Software Engineer&quot;</span><span class="token punctuation">,</span>
  <span class="token function-variable function">sayName</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li></ul> <p>这些属性在创建时都带有一些<strong>特征值（characteristic）</strong>，JavaScript 通过这些特征值来定义它们的行为。</p> <h3 id="_6-1-1-属性类型"><a href="#_6-1-1-属性类型" class="header-anchor">#</a> 6.1.1 属性类型</h3> <p><strong><em>1. 特性与属性</em></strong></p> <p>ECMA-262 第 5 版在定义<strong>只有内部才用的</strong>特性（attribute）时，描述了属性（property）的各种特征。（<strong>attribute</strong> /əˈtrɪbju:t/ 属性; （人或物的） 特征 <strong>property</strong> /ˈprɒpəti/ 特性，属性; 财产，地产; ）</p> <ul><li>这些特性是<strong>为了实现 JavaScript 引擎</strong>用的，因此在 JavaScript 中不能直接访问它们。</li> <li>为了表示特性是内部值，该规范把它们放在了<strong>两对儿方括</strong>号中，例如[[Enumerable]]。</li></ul> <p>ECMAScript 中有两种属性：数据属性和访问器属性。</p> <p><strong><em>2. 数据属性</em></strong></p> <p>数据属性包含一个数据值的位置。在这个位置可以读取和写入值。</p> <p>数据属性有 4 个描述其<strong>行为的特性</strong>。</p> <ul><li><p>[[Configurable]]：表示<strong>能否通过 delete 删除属性</strong>从而重新定义属性，<strong>能否修改属性的特性</strong>，或者<strong>能否把属性修改为访问器属性</strong>。（不可配置）（<strong>Configurable /kən'fɪgərəbl]/ 结构的，可配置的</strong>;）</p></li> <li><ul><li>直接在对象上定义的属性，它们的这个特性<strong>默认值为 true</strong>。</li></ul></li> <li><p>[[Enumerable]]：表示能<strong>否通过 for-in 循环返回属性</strong>。（<strong>Enumerable /ɪ'nju:mərəbə/ 可列举的;</strong>）</p></li> <li><ul><li>直接在对象上定义的属性，它们的这个特性<strong>默认值为 true</strong>。</li></ul></li> <li><p>[[Writable]]：表示<strong>能否修改属性的值</strong>。（只读）</p></li> <li><ul><li>直接在对象上定义的属性，它们的这个特性<strong>默认值为 true</strong>。</li></ul></li> <li><p>[[Value]]：包含这个<strong>属性的数据值</strong>。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。（<strong>特征值</strong>）</p></li> <li><ul><li>这个特性的<strong>默认值为 undefined</strong>。</li></ul></li> <li><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><ul><li>它的[[Configurable]]、[[Enumerable]]和[[Writable]]特性都被设置为 true，而[[Value]]特性被设置为指定的值。</li> <li>[[Value]]特性将被设置为&quot;Nicholas&quot;，而对这个值的任何修改都将反映在这个位置。</li></ul></li></ul> <p>要<strong>修改属性默认的特性</strong>，必须使用 ECMAScript 5 的 Object.defineProperty()方法。</p> <ul><li><p>这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。</p></li> <li><p>描述符（descriptor）对象的属性必须是：configurable、enumerable、writable 和 value。设置其中的一或多个值，可以修改对应的特性值。</p></li> <li><p>举例：设置<strong>只读属性（[[Writable]]）</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">&quot;name&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  writable<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  value<span class="token operator">:</span> <span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Nicholas&quot;</span>
person<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Greg&quot;</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Nicholas&quot;</span>
</code></pre></div><ul><li><p>名为 name 的属性，它的值&quot;Nicholas&quot;是只读的。属性的值是不可修改的，如果尝试为它指定新值</p></li> <li><ul><li>在非严格模式下，赋值操作将被忽略；</li> <li>在严格模式下，赋值操作将会导致抛出错误。</li></ul></li></ul></li> <li><p>举例：设置<strong>不可配置属性（[[Configurable]]）</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">&quot;name&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  configurable<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  value<span class="token operator">:</span> <span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Nicholas&quot;</span>
<span class="token keyword">delete</span> person<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Nicholas&quot;</span>
</code></pre></div><ul><li><p>把 configurable 设置为 false，表示不能从对象中删除属性。如果对这个属性调用 delete，</p></li> <li><ul><li>在非严格模式下什么也不会发生，</li> <li>而在严格模式下会导致错误。</li></ul></li> <li><p>而且，一旦把属性定义为不可配置的，就不能再把它变回可配置了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">&quot;name&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  configurable<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  value<span class="token operator">:</span> <span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//抛出错误</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">&quot;name&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  value<span class="token operator">:</span> <span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>再调用 Object.defineProperty()方法修改除 writable 之外的特性，都会导致错误。多次调用 Object.defineProperty()方法修改同一个属性，但在把 configurable 特性设置为 false 之后就会有限制了。</li></ul></li></ul></li> <li><p>在调用 Object.defineProperty()方法时，如果不指定，configurable、enumerable 和 writable 特性的默认值都是 false。</p></li> <li><p>多数情况下，可能都没有必要利用 Object.defineProperty()方法提供的这些高级功能。不过，理解这些概念对理解 JavaScript 对象却非常有用。</p></li> <li><p>IE8 是第一个实现 Object.defineProperty()方法的浏览器版本。然而，这个版本的实现存在诸多限制：只能在 DOM 对象上使用这个方法，而且只能创建访问器属性。由于实现不彻底，建议读者不要在 IE8 中使用 Object.defineProperty()方法。</p></li></ul> <p><strong><em>3. 访问器属性</em></strong></p> <ul><li><p>访问器属性不包含数据值；它们包含一对儿 getter 和 setter 函数（不过，这两个函数都不是必需的）。</p></li> <li><ul><li>在读取访问器属性时，会调用 getter 函数，这个函数负责返回有效的值；</li> <li>在写入访问器属性时，会调用 setter 函数并传入新值，这个函数负责决定如何处理数据。</li></ul></li> <li><p>访问器属性有如下 4 个特性。</p></li> <li><ul><li><p>[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。</p></li> <li><ul><li>对于直接在对象上定义的属性，这个特性的默认值为 true。</li></ul></li> <li><p>[[Enumerable]]：表示能否通过 for-in 循环返回属性。</p></li> <li><ul><li>对于直接在对象上定义的属性，这个特性的默认值为 true。</li></ul></li> <li><p>[[Get]]：在读取属性时调用的函数。</p></li> <li><ul><li>默认值为 undefined。</li></ul></li> <li><p>[[Set]]：在写入属性时调用的函数。</p></li> <li><ul><li>默认值为 undefined。</li></ul></li></ul></li> <li><p><strong>访问器属性不能直接定义</strong>，必须使用 Object.defineProperty()来定义。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> book <span class="token operator">=</span> <span class="token punctuation">{</span>
  _year<span class="token operator">:</span> <span class="token number">2004</span><span class="token punctuation">,</span>
  edition<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>book<span class="token punctuation">,</span> <span class="token string">&quot;year&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_year<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">newValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newValue <span class="token operator">&gt;</span> <span class="token number">2004</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>_year <span class="token operator">=</span> newValue<span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>edition <span class="token operator">+=</span> newValue <span class="token operator">-</span> <span class="token number">2004</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

book<span class="token punctuation">.</span>year <span class="token operator">=</span> <span class="token number">2005</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>book<span class="token punctuation">.</span>edition<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//2</span>
</code></pre></div><ul><li><p>定义两个默认的属性：_year 和 edition。</p></li> <li><ul><li>_year 前面的<strong>下划线是一种常用的记号，用于表示只能通过对象方法访问的属性</strong>。</li></ul></li> <li><p>访问器属性 year</p></li> <li><ul><li><p>包含一个 getter 函数和一个 setter 函数。getter 函数返回_year 的值，setter 函数通过计算来确定正确的版本。因此，把 year 属性修改为 2005 会导致_year 变成 2005，而 edition 变为 2。</p></li> <li><p>使用访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化。</p></li> <li><p>不一定非要同时指定 getter 和 setter。</p></li> <li><ul><li><p>只指定 getter 意味着属性是不能写，</p></li> <li><ul><li>尝试写入属性会被忽略。</li> <li>在严格模式下，尝试写入只指定了 getter 函数的属性会抛出错误。</li></ul></li> <li><p>只指定 setter 函数的属性也不能读，</p></li> <li><ul><li>在非严格模式下会返回 undefined，</li> <li>而在严格模式下会抛出错误。</li></ul></li></ul></li></ul></li></ul></li> <li><p>支持 ECMAScript 5 的这个方法的浏览器有 IE9+（IE8 只是部分实现）、Firefox 4+、Safari 5+、Opera12+ 和 Chrome 。</p></li> <li><p>在这个方法之前， 要创建访问器属性， 一般都使用两个非标准的方法：_defineGetter**()和**defineSetter__()。这两个方法最初是由 Firefox 引入的</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> book <span class="token operator">=</span> <span class="token punctuation">{</span>
  _year<span class="token operator">:</span> <span class="token number">2004</span><span class="token punctuation">,</span>
  edition<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//定义访问器的旧有方法</span>
book<span class="token punctuation">.</span><span class="token function">__defineGetter__</span><span class="token punctuation">(</span><span class="token string">&quot;year&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_year<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

book<span class="token punctuation">.</span><span class="token function">__defineSetter__</span><span class="token punctuation">(</span><span class="token string">&quot;year&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">newValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>newValue <span class="token operator">&gt;</span> <span class="token number">2004</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_year <span class="token operator">=</span> newValue<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>edition <span class="token operator">+=</span> newValue <span class="token operator">-</span> <span class="token number">2004</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

book<span class="token punctuation">.</span>year <span class="token operator">=</span> <span class="token number">2005</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>book<span class="token punctuation">.</span>edition<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//2</span>
</code></pre></div></li> <li><p>在不支持 Object.defineProperty() 方法的浏览器中不能修改[[Configurable]] 和[[Enumerable]]。</p></li></ul> <h3 id="_6-1-2-定义多个属性"><a href="#_6-1-2-定义多个属性" class="header-anchor">#</a> 6.1.2 定义多个属性</h3> <p><strong><em>1. 一次定义多个属性</em></strong></p> <p>由于为对象定义多个属性的可能性很大，ECMAScript 5 又定义了一个 Object.defineProperties()方法。</p> <ul><li><p>利用这个方法可以通过<strong>描述符</strong> <strong>一次定义</strong>多个属性。</p></li> <li><p>这个方法接收两个对象参数：</p></li> <li><ul><li>第一个对象是要添加和修改其属性的对象，</li> <li>第二个对象的属性与第一个对象中要添加或修改的属性一一对应。</li></ul></li> <li><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> book <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

Object<span class="token punctuation">.</span><span class="token function">defineProperties</span><span class="token punctuation">(</span>book<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  _year<span class="token operator">:</span> <span class="token punctuation">{</span>
    value<span class="token operator">:</span> <span class="token number">2004</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  edition<span class="token operator">:</span> <span class="token punctuation">{</span>
    value<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  year<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_year<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">newValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>newValue <span class="token operator">&gt;</span> <span class="token number">2004</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>_year <span class="token operator">=</span> newValue<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>edition <span class="token operator">+=</span> newValue <span class="token operator">-</span> <span class="token number">2004</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><ul><li>定义了两个<strong>数据属性（_year 和 edition</strong>）和一个<strong>访问器属性（year）</strong>。最终的对象与上一节中定义的对象相同。（理解：描述符对象的形式创建数据属性）</li> <li>唯一的区别是这里的属性都是在<strong>同一时间创建</strong>的。</li></ul></li> <li><p>支持 Object.defineProperties()方法的浏览器有 IE9+、Firefox 4+、Safari 5+、Opera 12+和 Chrome。</p></li></ul> <h3 id="_6-1-3-读取属性的特性"><a href="#_6-1-3-读取属性的特性" class="header-anchor">#</a> 6.1.3 读取属性的特性</h3> <p><strong><em>1. 读取属性的特性</em></strong></p> <p>使用 ECMAScript 5 的 Object.getOwnPropertyDescriptor()方法，可以取得给定属性的<strong>描述符</strong>。（<strong>Descriptor /dɪˈskrɪptə(r)/ 描述符</strong>）</p> <ul><li><p>这个方法接收两个参数：</p> <ul><li>属性所在的对象</li> <li>要读取其描述符的属性名称</li></ul></li> <li><p>返回值是一个对象：</p></li> <li><ul><li>如果是<strong>访问器属性</strong>，这个对象的属性有 configurable、enumerable、get 和 set；</li> <li>如果是<strong>数据属性</strong>，这个对象的属性有 configurable、enumerable、writable 和 value。</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> book <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

Object<span class="token punctuation">.</span><span class="token function">defineProperties</span><span class="token punctuation">(</span>book<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  _year<span class="token operator">:</span> <span class="token punctuation">{</span>
    value<span class="token operator">:</span> <span class="token number">2004</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  edition<span class="token operator">:</span> <span class="token punctuation">{</span>
    value<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  year<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_year<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">newValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>newValue <span class="token operator">&gt;</span> <span class="token number">2004</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>_year <span class="token operator">=</span> newValue<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>edition <span class="token operator">+=</span> newValue <span class="token operator">-</span> <span class="token number">2004</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> descriptor <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>book<span class="token punctuation">,</span> <span class="token string">&quot;_year&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>descriptor<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//2004</span>
<span class="token function">alert</span><span class="token punctuation">(</span>descriptor<span class="token punctuation">.</span>configurable<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//false</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> descriptor<span class="token punctuation">.</span>get<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;undefined&quot;</span>

<span class="token keyword">var</span> descriptor <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>book<span class="token punctuation">,</span> <span class="token string">&quot;year&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>descriptor<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//undefined</span>
<span class="token function">alert</span><span class="token punctuation">(</span>descriptor<span class="token punctuation">.</span>enumerable<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//false</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> descriptor<span class="token punctuation">.</span>get<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;function&quot;</span>
</code></pre></div><ul><li>对于数据属性_year，value 等于最初的值，configurable 是 false，而 get 等于 undefined。</li> <li>对于访问器属性 year，value 等于 undefined，enumerable 是 false，而 get 是一个指向 getter 函数的指针。</li></ul> <p>在 JavaScript 中，可以针对任何对象——包括 DOM 和 BOM 对象，使用 Object.getOwnPropertyDescriptor()方法。</p> <p>支持这个方法的浏览器有 IE9+、Firefox 4+、Safari 5+、Opera 12+和 Chrome。</p> <h2 id="_6-2-创建对象"><a href="#_6-2-创建对象" class="header-anchor">#</a> 6.2 创建对象</h2> <p><strong><em>1. 构造函数或对象字面量缺点</em></strong></p> <p>虽然 Object 构造函数或对象字面量都可以用来创建<strong>单个对象</strong>，但这些方式有个明显的缺点：</p> <ul><li><p>使用同一个接口创建很多对象</p></li> <li><p>会产生大量的重复代码</p></li></ul> <p>为解决这个问题，人们开始使用<strong>工厂模式的一种变体</strong>。（本单元主要讲演变过程）</p> <p><strong><em>2. 三种创建对象的方法：</em></strong></p> <p>通过<strong>object</strong>方式创建。</p> <p>通过”<strong>字面量</strong>“方式创建。</p> <p>通过”<strong>构造函数</strong>“方式创建。（即本章内容，理解：其实一下都是”构造函数“方式的变形，也是<strong>工厂模式的变形</strong>（下面所有都是工厂模式的变形））</p> <ol><li>工厂模式</li> <li>构造函数模式（即第三种创建对象的方法）</li> <li>原型模式</li> <li>组合使用构造函数模式和原型模式</li> <li>动态原型模式</li> <li>寄生构造函数模式</li> <li>稳妥构造函数模式</li></ol> <h3 id="_6-2-1-工厂模式"><a href="#_6-2-1-工厂模式" class="header-anchor">#</a> 6.2.1 工厂模式</h3> <p><strong><em>1. 定义</em></strong></p> <p>工厂模式定义：</p> <ul><li>工厂模式是我们最常用的实例化对象模式了，是用<strong>工厂方法代替 new 操作</strong>的一种模式。（理解：创建时不用 new，<strong>封装了 new</strong>）</li> <li>工厂模式是软件工程领域一种广为人知的设计模式，这种模式<strong>抽象了创建</strong>具体对象的过程（本书后面还将讨论其他设计模式及其在 JavaScript 中的实现）。</li></ul> <p><strong><em>2. 实例</em></strong></p> <p>考虑到在<strong>ECMAScript 中无法创建类</strong>（理解：不能创建类，只能模拟类），开发人员就发明了一种函数，用函数来<strong>封装以特定接口创建对象的细节</strong>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> job</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  o<span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  o<span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
  o<span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span>
  o<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> o<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token string">&quot;Software Engineer&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token string">&quot;Greg&quot;</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">,</span> <span class="token string">&quot;Doctor&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>函数 createPerson()能够根据接受的参数来构建一个包含所有必要信息的 Person 对象。</li> <li>可以无数次地调用这个函数返回对象。</li></ul> <p><strong><em>3. 缺点</em></strong></p> <ul><li>工厂模式虽然解决了创建多个相似对象的问题，但却<strong>没有解决对象识别</strong>的问题（即怎样知道一个对象的类型）。</li> <li>随着 JavaScript 的发展，又一个新模式出现了。</li></ul> <h3 id="_6-2-2-构造函数模式"><a href="#_6-2-2-构造函数模式" class="header-anchor">#</a> 6.2.2 构造函数模式</h3> <p><strong><em>1. 定义</em></strong></p> <p>ECMAScript 中的构造函数可用来创建特定类型的对象（前几章介绍过）</p> <ul><li>像 Object 和 Array 这样的<strong>原生构造函数</strong>，在运行时会自动出现在执行环境中。</li> <li>此外，也可以创建<strong>自定义的构造函数</strong>，从而定义自定义对象类型的属性和方法。</li></ul> <p><strong><em>2. 实例</em></strong></p> <p>使用构造函数模式将前面的例子重写如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> job</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token string">&quot;Software Engineer&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Greg&quot;</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">,</span> <span class="token string">&quot;Doctor&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong><em>3. 实例使用细节/代码解读</em></strong></p> <ul><li><p>Person()函数取代了 createPerson()函数。</p></li> <li><p>Person()中的代码除了与 createPerson()中相同的部分外，还存在以下不同之处：</p></li> <li><ul><li>没有显式地创建对象；</li> <li>直接将属性和方法赋给了 this 对象；</li> <li>没有 return 语句。</li></ul></li> <li><p>还应该注意到函数名 Person 使用的是大写字母 P。</p></li> <li><ul><li>按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。</li> <li>这个做法借鉴自其他 OO 语言，主要是为了区别于 ECMAScript 中的其他函数；因为构造函数本身也是函数，只不过可以用来创建对象而已。</li></ul></li> <li><p>要创建 Person 的新实例，必须使用 new 操作符。</p></li></ul> <p><strong><em>4. 使用原理/构造函数模式解读：</em></strong></p> <ul><li><p>以这种方式调用构造函数实际上会经历以下 4 个步骤：</p></li> <li><ol><li>创建一个新对象；</li> <li>将<strong>构造函数的作用域</strong>赋给新对象（因此 this 就指向了这个新对象）；</li> <li>执行构造函数中的代码（为这个新对象添加属性）；</li> <li><strong>返回新对象</strong>。</li></ol></li> <li><p>在前面例子的最后，person1 和 person2 分别保存着 Person 的一个不同的实例。这两个对象都有一个<strong>constructor（构造函数）属性指向 Person</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
</code></pre></div></li> <li><p>对象的 constructor 属性<strong>最初是用来标识对象类型</strong>的。</p></li> <li><p>但是，提到检测对象类型，还是 instanceof 操作符要更可靠一些。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">alert</span><span class="token punctuation">(</span>person1 <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person1 <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person2 <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person2 <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
</code></pre></div><ul><li>创建自定义的构造函数意味着将来<strong>可以将它的实例标识为一种特定的类型</strong>；而这正是<strong>构造函数模式胜过工厂模式的地方</strong>。</li> <li>在这个例子中，person1 和 person2 之所以同时是 Object 的实例，是因为所有对象均继承自 Object（详细内容稍后讨论）。</li></ul></li> <li><p>以这种方式定义的构造函数是定义在 Global 对象（在浏览器中是 window 对象）中的。第 8 章将详细讨论浏览器对象模型（BOM）。</p></li></ul> <p><strong><em>5. 将构造函数当作函数</em></strong></p> <p>构造函数与其他函数的异同：</p> <ul><li><p>构造函数与其他函数的唯一区别，就在于调用它们的方式不同。</p></li> <li><ul><li>构造函数毕竟也是函数，不存在定义构造函数的特殊语法。</li> <li>任何函数，<strong>只要通过 new 操作符来调用，那它就可以作为构造函数</strong>；而任何函数，如果不通过 new 操作符来调用，那它跟普通函数也不会有什么两样。</li></ul></li></ul> <p>示例：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 当作构造函数使用</span>
<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token string">&quot;Software Engineer&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
person<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Nicholas&quot;</span>

<span class="token comment">// 作为普通函数调用</span>
<span class="token function">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Greg&quot;</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">,</span> <span class="token string">&quot;Doctor&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 添加到window</span>
window<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Greg&quot;</span>

<span class="token comment">// 在另一个对象的作用域中调用</span>
<span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Person</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> <span class="token string">&quot;Kristen&quot;</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token string">&quot;Nurse&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
o<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Kristen&quot;</span>
</code></pre></div><ul><li>不使用 new 操作符调用 Person()会出现什么结果：属性和方法都被添加给 window 对象了。</li> <li>当在全局作用域中调用一个函数时，<strong>this 对象总是指向 Global 对象</strong>（<strong>在浏览器中就是 window 对象</strong>）。</li> <li>使用 call()（或者 apply()）在某个特殊对象的作用域中调用 Person()函数。</li></ul> <p><strong><em>6. 缺点：构造函数的问题</em></strong></p> <p>主要问题：</p> <ul><li><p>构造函数模式虽然好用，但也并非没有缺点。使用构造函数的主要问题，就是<strong>每个方法都要在每个实例上重新创建</strong>一遍。</p> <ul><li>在前面的例子中，person1 和 person2 都有一个名为 sayName()的方法，但那两个方法不是同一个 Function 的实例。</li></ul></li> <li><p>不要忘了——<strong>ECMAScript 中的函数是对象，因此每定义一个函数，也就是实例化了一个对象</strong>(理解;函数对象 )。从逻辑角度讲，此时的构造函数也可以这样定义。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> job</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sayName <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token string">&quot;alert(this.name)&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 与声明函数在逻辑上是等价的</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><p>从这个角度上来看构造函数，更容易明白每个 Person 实例都包含一个不同的 Function 实例（以显示 name 属性）的本质。</p></li> <li><p>以这种方式创建函数，会导致不同的作用域链和标识符解析，但创建 Function 新实例的机制仍然是相同的。因此，<strong>不同实例上的同名函数是不相等的</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>sayName <span class="token operator">==</span> person2<span class="token punctuation">.</span>sayName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//false</span>
</code></pre></div></li></ul></li></ul> <p>解法：</p> <ul><li><p>创建两个完成同样任务的 Function 实例的确没有必要</p></li> <li><p>有 this 对象在，根本不用在执行代码前就把函数绑定到特定对象上面。</p></li> <li><p>因此，通过<strong>把函数定义转移到构造函数外部</strong>来解决这个问题。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> job</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sayName <span class="token operator">=</span> sayName<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token string">&quot;Software Engineer&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Greg&quot;</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">,</span> <span class="token string">&quot;Doctor&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>由于 sayName 包含的是一个指向函数的指针，因此 person1 和 person2 对象就共享了在全局作用域中定义的同一个 sayName()函数。</li></ul></li></ul> <p><strong><em>6. 缺点：新的问题</em></strong></p> <p>新问题又来了：</p> <p>在全局作用域中定义的函数实际上只能被某个对象调用，这让全局作用域有点名不副实。而更让人无法接受的是：如果对象需要定义很多方法，那么就要<strong>定义很多个全局函数</strong>，于是我们这个自定义的引用类型就<strong>丝毫没有封装性</strong>可言了。</p> <p>解法：</p> <p>好在，这些问题可以通过使用<strong>原型模式</strong>来解决。</p> <h3 id="_6-2-3-原型模式"><a href="#_6-2-3-原型模式" class="header-anchor">#</a> 6.2.3 原型模式</h3> <p><strong><em>1. prototype（原型）属性定义</em></strong></p> <p>我们创建的每个函数都有一个 prototype（原型）属性，<strong>prototype（原型）属性是一个指针，指向一个对象</strong>，而<strong>这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法</strong>。（可以粗理解：属性即对象）</p> <ul><li>如果按照字面意思来理解，那么 prototype 就是通过调用构造函数而创建的那个<strong>对象实例的原型对象</strong>。</li> <li>使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。</li> <li>换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">29</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>job <span class="token operator">=</span> <span class="token string">&quot;Software Engineer&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
person1<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Nicholas&quot;</span>

<span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
person2<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Nicholas&quot;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>sayName <span class="token operator">==</span> person2<span class="token punctuation">.</span>sayName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
</code></pre></div><ul><li>将 sayName()方法和所有属性直接添加到了 Person 的 prototype 属性中，构造函数变成了空函数。</li> <li>即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法。但与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。换句话说，person1 和 person2 访问的都是同一组属性和同一个 sayName()函数。</li></ul> <p>要理解<strong>原型模式的工作原理</strong>，必须先理解 ECMAScript 中<strong>原型对象的性质</strong>。</p> <p><strong><em>2. 原型对象的性质</em></strong></p> <p>理解构造函数、原型属性、实例的关系</p> <ol><li>创建函数（类）阶段（①，②）
<ul><li>无论什么时候，只要创建了一个新函数，就<strong>会根据一组特定的规则为该函数创建一个 prototype 属性</strong>，这个属性<strong>指向原型对象</strong>。（①，不是新对象，是新构造函数 Person()；理解原型函数在什么时候产生）</li> <li>在默认情况下，所有原型对象都<strong>会自动获得一个 constructor（构造函数）属性</strong>，这个属性包含一个<strong>指向 prototype 属性所在函数</strong>的指针。就拿前面的例子来说，Person.prototype. constructor 指向 Person。而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。（②，）</li> <li>创建了自定义的构造函数之后，其原型对象<strong>默认只会取得 constructor 属性</strong>；至于其他方法，则都是从 Object 继承而来的。（②，原型对象）</li></ul></li> <li>创建实例阶段（③）
<ul><li>当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），<strong>指向构造函数的原型对象</strong>。ECMA-262 第 5 版中管这个指针叫[[Prototype]]。（③，内部属性表示：<strong>[[Prototype]]，内部属性是无法访问的</strong>）</li> <li>虽然在脚本中没有标准的方式访问[[Prototype]]，但 Firefox、Safari 和 Chrome 在每个对象上<strong>都支持一个属性__proto__</strong>；而在其他实现中，这个属性对脚本则是完全不可见的。（③）</li> <li>不过，要明确的真正重要的一点就是，<strong>这个连接存在于实例与构造函数的原型对象之间</strong>，而<strong>不是存在于实例与构造函数之间</strong>。（③，这个是理解的重点和基础）</li></ul></li></ol> <p><img src="https://cdn.jsdelivr.net/gh/coalyer/image-store@master/blog/professionalJs/prototype_constructor.png" alt="prototype_constructor"></p> <p>展示了 Person <strong>构造函数</strong>、Person 的<strong>原型属性</strong>以及 Person <strong>实例</strong>之间的关系。</p> <ul><li>在此，Person.prototype 指向了原型对象，而 Person.prototype.constructor 又指回了 Person。</li> <li>原型对象中除了包含 constructor 属性之外，还包括后来添加的其他属性。</li> <li>Person 的每个实例——person1 和 person2 都包含一个内部属性，该属性仅仅指向了 Person.prototype；换句话说，它们与<strong>构造函数没有直接的关系</strong>。</li> <li>此外，要格外注意的是，虽然这两个实例都不包含属性和方法，但我们却可以调 person1.sayName()。这是<strong>通过查找对象属性的过程来实现</strong>的。</li></ul> <p><strong><em>3. 判断原型属性</em></strong></p> <ul><li><p>虽然在所有实现中都无法访问到[[Prototype]]，但可以通过 isPrototypeOf()方法来确<strong>定对象之间是否存在这种关系</strong>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">alert</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>person1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
</code></pre></div></li> <li><ul><li>从本质上讲，<strong>如果[[Prototype]]指向调用 isPrototypeOf()方法的对象（Person.prototype），那么这个方法就返回 true</strong></li> <li>因为它们内部都有一个指向 Person.prototype 的指针，因此都返回了 true。</li></ul></li> <li><p>ECMAScript 5 增加了一个新方法，叫 Object.getPrototypeOf()，在所有支持的实现中，这个方法<strong>返回[[Prototype]]的值</strong>。（理解：getPrototypeOf()是 Object 的方法，而非实例的方法）</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">alert</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>person1<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
<span class="token function">alert</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>person1<span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Nicholas&quot;</span>
</code></pre></div><ul><li>使用 Object.getPrototypeOf()可以方便地取得一个对象的原型，而这在利用原型实现继承（本章稍后会讨论）的情况下是非常重要的。</li> <li>支持这个方法的浏览器有 IE9+、Firefox 3.5+、Safari 5+、Opera 12+和 Chrome。</li></ul></li></ul> <p>***4. 访问原型属性</p> <p>查找对象属性的过程<a name="查找对象属性的过程"></a></p> <ul><li>每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。</li> <li><strong>这正是多个对象实例共享原型所保存的属性和方法的基本原理</strong>。</li> <li>前面提到过，原型最初只包含 constructor 属性，而该属性也是共享的，因此可以通过对象实例访问。</li></ul> <p>前面提到过，原型最初只包含 constructor 属性，而该属性也是共享的，因此可以通过对象实例访问。</p> <p>虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">29</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>job <span class="token operator">=</span> <span class="token string">&quot;Software Engineer&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

person1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Greg&quot;</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Greg&quot;——来自实例</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Nicholas&quot;——来自原型</span>
</code></pre></div><ul><li>如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。</li> <li>访问 person2.name 时，并没有在实例上发现该属性，因此就会继续搜索原型，结果在那里找到了 name 属性。</li></ul> <p>当为对象实例添加一个属性时，这个属性就会<strong>屏蔽</strong>原型对象中保存的同名属性；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">29</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>job <span class="token operator">=</span> <span class="token string">&quot;Software Engineer&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

person1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Greg&quot;</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Greg&quot;——来自实例</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Nicholas&quot;——来自原型</span>

<span class="token keyword">delete</span> person1<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Nicholas&quot;——来自原型</span>
</code></pre></div><ul><li>换句话说，添加这个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。</li> <li>即使将这个属性设置为 null，也只会在实例中设置这个属性，而不会恢复其指向原型的连接。</li> <li>不过，使用 delete 操作符则可以完全删除实例属性，从而让我们能够重新访问原型中的属性</li> <li>使用 delete 操作符之前保存的&quot;Greg&quot;值屏蔽了同名的原型属性。把它删除以后，就恢复了对原型中 name 属性的连接。</li></ul> <p>使用 hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">29</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>job <span class="token operator">=</span> <span class="token string">&quot;Software Engineer&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//false</span>

person1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Greg&quot;</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Greg&quot;——来自实例</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>

<span class="token function">alert</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Nicholas&quot;——来自原型</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//false</span>

<span class="token keyword">delete</span> person1<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Nicholas&quot;——来自原型</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//false</span>
</code></pre></div><ul><li><p>这个方法（不要忘了它是从 Object 继承来的）只在给定属性存在于<strong>对象实例</strong>中时，才会返回 true。</p></li> <li><p>只有当 person1 重写 name 属性后才会返回 true，因为只有这时候 name 才是一个实例属性，而非原型属性。</p></li> <li><p>在不同情况下的实现与原型的关系（为了简单起见，图中省略了与 Person 构造函数的关系）。</p> <p><img src="https://cdn.jsdelivr.net/gh/coalyer/image-store@master/blog/professionalJs/prototype_object.png" alt="prototype_object"></p></li></ul> <p>CMAScript 5 的 Object.getOwnPropertyDescriptor()方法只能用于实例属性，要取得原型属性的描述符，必须直接在原型对象上调用 Object.getOwnPropertyDescriptor()方法。</p> <p><strong><em>5. 原型与 in 操作符</em></strong></p> <p>有两种方式使用 in 操作符：</p> <ul><li>单独使用</li> <li>for-in 循环中使用</li></ul> <p>单独使用时：</p> <ul><li><p>in 操作符会在通过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">29</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>job <span class="token operator">=</span> <span class="token string">&quot;Software Engineer&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//false</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span> <span class="token keyword">in</span> person1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>

person1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Greg&quot;</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Greg&quot; ——来自实例</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span> <span class="token keyword">in</span> person1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>

<span class="token function">alert</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Nicholas&quot; ——来自原型</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//false</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span> <span class="token keyword">in</span> person2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>

<span class="token keyword">delete</span> person1<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Nicholas&quot; ——来自原型</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//false</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span> <span class="token keyword">in</span> person1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
</code></pre></div><ul><li>调用&quot;name&quot; in person1 始终都返回 true，无论该属性存在于实例中还是存在于原型中。</li></ul></li> <li><p>同时使用 hasOwnProperty()方法和 in 操作符，就可以确定该属性到底是存在于对象中，还是存在于原型中</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">hasPrototypeProperty</span><span class="token punctuation">(</span><span class="token parameter">object<span class="token punctuation">,</span> name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token operator">!</span>object<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> name <span class="token keyword">in</span> object<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><p>由于 in 操作符只要通过对象能够访问到属性就返回 true，hasOwnProperty()只在属性存在于实例中时才返回 true，因此只要 in 操作符返回 true 而 hasOwnProperty()返回 false，就可以确定属性是原型中的属性。</p></li> <li><p>下面来看一看上面定义的函数 hasPrototypeProperty()的用法。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">29</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>job <span class="token operator">=</span> <span class="token string">&quot;Software Engineer&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token function">hasPrototypeProperty</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>

person<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Greg&quot;</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token function">hasPrototypeProperty</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//false</span>
</code></pre></div></li> <li><p>name 属性先是存在于原型中，因此 hasPrototypeProperty()返回 true。</p></li> <li><p>在实例中重写 name 属性后，该属性就存在于实例中了，因此 hasPrototypeProperty()返回 false。即使原型中仍然有 name 属性，但由于现在实例中也有了这个属性，因此原型中的 name 属性就用不到了。</p></li></ul></li></ul> <p>for-in 循环中使用时：</p> <ul><li><p>返回的是所有能够通过对象访问的、可枚举的（enumerated）属性：</p> <ul><li>既包括存在于实例中的属性</li> <li>也包括存在于原型中的属性</li></ul></li> <li><p><strong>屏蔽原型中不可枚举属性（即将[[Enumerable]]标记为 false 的属性）的实例属性</strong>也会在 for-in 循环中返回。</p> <ul><li><p>因为根据规定，<strong>所有开发人员定义的属性都是可枚举的</strong>——只有在 IE8 及更早版本中例外。（不可枚举的实例属性，不是不可枚举的原型属性）</p></li> <li><p>IE 早期版本的实现中存在一个 bug，即屏蔽不可枚举属性的实例属性不会出现在 for-in 循环中。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">toString</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">&quot;My Object&quot;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> prop <span class="token keyword">in</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>prop <span class="token operator">==</span> <span class="token string">&quot;toString&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;Found toString&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//在IE 中不会显示</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>对象 o 定义了一个名为 toString()的方法，该方法屏蔽了原型中（不可枚举）的 toString()方法。在 IE 中，由于其实现认为原型的 toString()方法被打上了值为 false 的[[Enumerable]]标记，因此应该跳过该属性，结果我们就不会看到警告框。</li> <li>该 bug 会影响默认不可枚举的所有属性和方法，包括：hasOwnProperty()、propertyIsEnumerable()、toLocaleString()、toString()和 valueOf()。</li></ul></li></ul></li> <li><p>ECMAScript 5 也将<strong>constructor 和 prototype 属性的[[Enumerable]]特性设置为 false</strong>，但并不是所有浏览器都照此实现。</p></li></ul> <p>要取得对象上所有可枚举的实例属性，可以使用 ECMAScript 5 的 Object.keys()方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">29</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>job <span class="token operator">=</span> <span class="token string">&quot;Software Engineer&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> keys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>keys<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;name,age,job,sayName&quot;</span>

<span class="token keyword">var</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Rob&quot;</span><span class="token punctuation">;</span>
p1<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">31</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> p1keys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>p1keys<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;name,age&quot;</span>
</code></pre></div><ul><li>这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。</li> <li>变量 keys 中将保存一个数组，数组中是字符串&quot;name&quot;、&quot;age&quot;、&quot;job&quot;和&quot;sayName&quot;。</li> <li><strong>这个顺序也是它们在 for-in 循环中出现的顺序</strong>。</li> <li>如果是通过 Person 的实例调用，则 Object.keys()返回的数组只包含&quot;name&quot;和&quot;age&quot;这两个实例属性。</li></ul> <p>如果你想要得到所有实例属性，无论它是否可枚举，都可以使用 Object.getOwnPropertyNames()方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> keys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyNames</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>keys<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;constructor,name,age,job,sayName&quot;</span>
</code></pre></div><ul><li>注意结果中包含了不可枚举的 constructor 属性。</li> <li>Object.keys()和 Object.getOwnPropertyNames()方法都可以用来替代 for-in 循环。</li> <li>支持这两个方法的浏览器有 IE9+、Firefox 4+、Safari 5+、Opera12+和 Chrome。</li></ul> <p><strong><em>6. 更简单的原型语法</em></strong></p> <p>更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token number">29</span><span class="token punctuation">,</span>
  job<span class="token operator">:</span> <span class="token string">&quot;Software Engineer&quot;</span><span class="token punctuation">,</span>
  <span class="token function-variable function">sayName</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><p>前面曾经介绍过，每创建一个函数，就会同时创建它的 prototype 对象，这个对象也会自动获得 constructor 属性。</p></li> <li><p>而我们在这里使用的语法，本质上完全重写了默认的 prototype 对象，因此 constructor 属性也就变成了新对象的 constructor 属性（指向 Object 构造函数），不再指向 Person 函数。</p></li> <li><p>此时，尽管 instanceof 操作符还能返回正确的结果，但通过 constructor 已经无法确定对象的类型了，</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> friend <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>friend <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
<span class="token function">alert</span><span class="token punctuation">(</span>friend <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
<span class="token function">alert</span><span class="token punctuation">(</span>friend<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//false</span>
<span class="token function">alert</span><span class="token punctuation">(</span>friend<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Object<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
</code></pre></div><ul><li>用 instanceof 操作符测试 Object 和 Person 仍然返回 true，但 constructor 属性则等于 Object 而不等于 Person 了。</li></ul></li> <li><p>如果 constructor 的值真的很重要，可以像下面这样特意将它设置回适当的值。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  constructor<span class="token operator">:</span> Person<span class="token punctuation">,</span>
  name<span class="token operator">:</span> <span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token number">29</span><span class="token punctuation">,</span>
  job<span class="token operator">:</span> <span class="token string">&quot;Software Engineer&quot;</span><span class="token punctuation">,</span>
  <span class="token function-variable function">sayName</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><p>注意，以这种方式重设 constructor 属性会导致它的[[Enumerable]]特性被设置为 true。默认情况下，原生的 constructor 属性是不可枚举的，</p></li> <li><p>因此如果你使用兼容 ECMAScript 5 的 JavaScript 引擎，可以试一试 Object.defineProperty()。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token number">29</span><span class="token punctuation">,</span>
  job<span class="token operator">:</span> <span class="token string">&quot;Software Engineer&quot;</span><span class="token punctuation">,</span>
  <span class="token function-variable function">sayName</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//重设构造函数，只适用于ECMAScript 5 兼容的浏览器</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token string">&quot;constructor&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  enumerable<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  value<span class="token operator">:</span> Person<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul></li></ul> <p><strong><em>7. 原型的动态性</em></strong></p> <ul><li><p>对原型对象所做的任何修改都能够立即从实例上反映出来——即使是先<strong>创建了实例后修改原型也照样如此</strong>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> friend <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayHi</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;hi&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

friend<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;hi&quot;（没有问题！）</span>
</code></pre></div><ul><li>即使 person 实例是在添加新方法之前创建的，但它仍然可以访问这个新方法。其原因可以归结为实例与原型之间的松散连接关系。</li> <li>因为实例与原型之间的连接只不过是一个指针，而非一个副本，因此就可以在原型中找到新的 sayHi 属性并返回保存在那里的函数。</li></ul></li> <li><p>尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重写整个原型对象，那么情况就不一样了。</p></li> <li><ul><li><p>调用构造函数时会为实例添加一个指向最初原型的[[Prototype]]指针，而把<strong>原型修改为另外一个对象</strong>就等于<strong>切断了构造函数与最初原型之间的联系</strong>。</p></li> <li><p><strong>请记住：实例中的指针仅指向原型，而不指向构造函数</strong>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">var</span> friend <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  constructor<span class="token operator">:</span> Person<span class="token punctuation">,</span>
  name<span class="token operator">:</span> <span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token number">29</span><span class="token punctuation">,</span>
  job<span class="token operator">:</span> <span class="token string">&quot;Software Engineer&quot;</span><span class="token punctuation">,</span>
  <span class="token function-variable function">sayName</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

friend<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//error</span>
</code></pre></div></li> <li><ul><li><p>发生了错误，因为 friend 指向的原型中不包含以该名字命名的属性。</p> <p><img src="https://cdn.jsdelivr.net/gh/coalyer/image-store@master/blog/professionalJs/prototype_cut.png" alt="prototype_cut"></p></li> <li><p>重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系；它们引用的仍然是最初的原型。</p></li></ul></li></ul></li></ul> <p><strong><em>9. 原生对象的原型</em></strong></p> <p>原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。</p> <ul><li><p>所有原生引用类型（Object、Array、String，等等）都在其构造函数的原型上定义了方法。例如，在 Array.prototype 中可以找到 sort()方法，而在 String.prototype 中可以找到 substring()方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>sort<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;function&quot;</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token class-name">String</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>substring<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;function&quot;</span>
</code></pre></div></li></ul> <p>通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法。可以像修改自定义对象的原型一样修改原生对象的原型，因此可以随时添加方法。</p> <ul><li><p>下面的代码就给基本包装类型 String 添加了一个名为 startsWith()的方法。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">String</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">startsWith</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">text</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> msg <span class="token operator">=</span> <span class="token string">&quot;Hello world!&quot;</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
</code></pre></div><ul><li>新定义的 startsWith()方法会在传入的文本位于一个字符串开始时返回 true。</li> <li>当前环境中的所有字符串就都可以调用它。由于 msg 是字符串，而且后台会调用 String 基本包装函数创建这个字符串，因此通过 msg 就可以调用 startsWith()方法。</li> <li>尽管可以这样做，但我们不推荐在产品化的程序中修改原生对象的原型。
<ul><li>如果因某个实现中缺少某个方法，就在原生对象的原型中添加这个方法，那么当在另一个支持该方法的实现中运行代码时，就可能会导致命名冲突。而且，这样做也可能会意外地重写原生方法。</li></ul></li></ul></li></ul> <p><strong><em>10. 缺点：原型对象的问题</em></strong></p> <ul><li><p>首先，它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。</p></li> <li><ul><li>虽然这会在某种程度上带来一些不方便，但还不是原型的最大问题。</li></ul></li> <li><p>原型模式的最大问题是由其<strong>共享的本性所导致</strong>的。</p></li> <li><ul><li><p>原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性倒也说得过去，毕竟（如前面的例子所示），通过在实例上添加一个同名属性，可以隐藏原型中的对应属性。</p></li> <li><p>然而，对于包含引用类型值的属性来说，问题就比较突出了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  constructor<span class="token operator">:</span> Person<span class="token punctuation">,</span>
  name<span class="token operator">:</span> <span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token number">29</span><span class="token punctuation">,</span>
  job<span class="token operator">:</span> <span class="token string">&quot;Software Engineer&quot;</span><span class="token punctuation">,</span>
  friends<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;Shelby&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Court&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token function-variable function">sayName</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

person1<span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;Van&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Shelby,Court,Van&quot;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Shelby,Court,Van&quot;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>friends <span class="token operator">===</span> person2<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
</code></pre></div></li> <li><ul><li>由于 friends 数组存在于 Person.prototype 而非 person1 中，所以刚刚提到的修改也会通过 person2.friends（与 person1.friends 指向同一个数组）反映出来。</li> <li>实例一般都是要有属于自己的全部属性的。而这个问题正是我们很少看到有人单独使用原型模式的原因所在。</li></ul></li></ul></li></ul> <h3 id="_6-2-4-组合使用构造函数模式和原型模式"><a href="#_6-2-4-组合使用构造函数模式和原型模式" class="header-anchor">#</a> 6.2.4 组合使用构造函数模式和原型模式</h3> <p><strong><em>1. 组合使用构造函数模式和原型模式</em></strong></p> <p>创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。</p> <ul><li>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。</li> <li>结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。</li> <li>另外，这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。</li></ul> <p>实例：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> job</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>friends <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;Shelby&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Court&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  constructor<span class="token operator">:</span> Person<span class="token punctuation">,</span>
  <span class="token function-variable function">sayName</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token string">&quot;Software Engineer&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Greg&quot;</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">,</span> <span class="token string">&quot;Doctor&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

person1<span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;Van&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Shelby,Count,Van&quot;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person2<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Shelby,Count&quot;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>friends <span class="token operator">===</span> person2<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//false</span>
<span class="token function">alert</span><span class="token punctuation">(</span>person1<span class="token punctuation">.</span>sayName <span class="token operator">===</span> person2<span class="token punctuation">.</span>sayName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
</code></pre></div><ul><li>实例属性都是在构造函数中定义的，而由所有实例共享的属性 constructor 和方法 sayName()则是在原型中定义的。</li> <li>而修改了 person1.friends（向其中添加一个新字符串），并不会影响到 person2.friends，因为它们分别引用了不同的数组。</li></ul> <p>这种构造函数与原型混成的模式，是目前在 ECMAScript 中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。</p> <h3 id="_6-2-5-动态原型模式"><a href="#_6-2-5-动态原型模式" class="header-anchor">#</a> 6.2.5 动态原型模式</h3> <p><strong><em>1. 动态原型模式</em></strong></p> <p>有其他 OO 语言经验的开发人员在看到<strong>独立的构造函数和原型时，很可能会感到非常困惑</strong>。动态原型模式正是致力于解决这个问题的一个方案</p> <p>动态原型模式：</p> <ul><li>它把所有信息都封装在了构造函数中，而<strong>通过在构造函数中初始化原型</strong>（仅在必要的情况下）</li> <li>又保持了同时使用构造函数和原型的优点。</li> <li>换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。</li></ul> <p>实例：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> job</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//属性</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span>

  <span class="token comment">//方法</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span><span class="token punctuation">.</span>sayName <span class="token operator">!=</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> friend <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token string">&quot;Software Engineer&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
friend<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>只在 sayName()方法不存在的情况下，才会将它添加到原型中。这段代码只会在初次调用构造函数时才会执行。此后，原型已经完成初始化，不需要再做什么修改了。不过要记住，这里对原型所做的修改，能够立即在所有实例中得到反映。因此，这种方法确实可以说非常完美。</li> <li>其中，if 语句检查的可以是初始化之后应该存在的任何属性或方法——不必用一大堆 if 语句检查每个属性和每个方法；只要检查其中一个即可。</li> <li>对于采用这种模式创建的对象，还可以使用 instanceof 操作符确定它的类型。</li> <li>使用动态原型模式时，不能使用对象字面量重写原型。前面已经解释过了，如果在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的联系。</li></ul> <h3 id="_6-2-6-寄生构造函数模式"><a href="#_6-2-6-寄生构造函数模式" class="header-anchor">#</a> 6.2.6 寄生构造函数模式</h3> <p><strong><em>1. 寄生构造函数模式</em></strong></p> <p>通常，在前述的几种模式都不适用的情况下，可以使用寄生（parasitic）构造函数模式。</p> <p>这种模式的基本思想是创建一个函数，该函数的<strong>作用仅仅是封装创建对象的代码</strong>，然后再返回新创建的对象；但<strong>从表面上看，这个函数又很像是典型的构造函数</strong>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> job</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  o<span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  o<span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
  o<span class="token punctuation">.</span>job <span class="token operator">=</span> job<span class="token punctuation">;</span>
  o<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> o<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> friend <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token string">&quot;Software Engineer&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
friend<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Nicholas&quot;</span>
</code></pre></div><ul><li>除了使用 new 操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实是一模一样的。</li> <li><strong>构造函数在不返回值的情况下，默认会返回新对象实例</strong>。而通过在构造函数的末尾添加一个 return 语句，可以<strong>重写</strong>调用构造函数时返回的值。</li></ul> <p><strong><em>2. 适用场景</em></strong></p> <p>通常，在前述的几种模式都不适用的情况下，可以使用寄生（parasitic）构造函数模式。</p> <p>这个模式可以在特殊的情况下用来<strong>为对象创建构造函数</strong>。假设我们想创建一个具有额外方法的特殊数组。由于不能直接修改 Array 构造函数，因此可以使用这个模式。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">SpecialArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//创建数组</span>
  <span class="token keyword">var</span> values <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">//添加值</span>
  values<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>values<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">//添加方法</span>
  values<span class="token punctuation">.</span><span class="token function-variable function">toPipedString</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot;|&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment">//返回数组</span>
  <span class="token keyword">return</span> values<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> colors <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SpecialArray</span><span class="token punctuation">(</span><span class="token string">&quot;red&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;blue&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;green&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>colors<span class="token punctuation">.</span><span class="token function">toPipedString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;red|blue|green&quot;</span>
</code></pre></div><ul><li>首先创建了一个数组，然后 push()方法（用构造函数接收到的所有参数）初始化了数组的值。</li> <li>随后，又给数组实例添加了一个 toPipedString()方法，该方法返回以竖线分割的数组值。</li> <li>最后，将数组以函数值的形式返回。</li> <li>接着，我们调用了 SpecialArray 构造函数，向其中传入了用于初始化数组的值，此后又调用了 toPipedString()方法。</li></ul> <p><strong><em>3. 缺点</em></strong></p> <p>关于寄生构造函数模式，有一点需要说明：</p> <ul><li><p>首先，返回的对象与构造函数或者与构造函数的原型属性之间没有关系；</p></li> <li><ul><li>也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。</li></ul></li> <li><p>为此，不能依赖 instanceof 操作符来确定对象类型。</p></li> <li><p>由于存在上述问题，我们建议在可以使用其他模式的情况下，不要使用这种模式。</p></li></ul> <h3 id="_6-2-7-稳妥构造函数模式"><a href="#_6-2-7-稳妥构造函数模式" class="header-anchor">#</a> 6.2.7 稳妥构造函数模式</h3> <p><strong><em>1. 稳妥对象</em></strong></p> <p>道格拉斯·克罗克福德（Douglas Crockford）发明了 JavaScript 中的<strong>稳妥对象</strong>（durable objects）这个概念。</p> <ul><li>所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。</li> <li>稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用 this 和 new），或者在防止数据被其他应用程序（如 Mashup 程序）改动时使用。</li></ul> <p><strong><em>2. 稳妥构造函数模式</em></strong></p> <p>稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：</p> <ul><li>一是新创建对象的实例方法不引用 this；</li> <li>二是不使用 new 操作符调用构造函数。</li></ul> <p>按照稳妥构造函数的要求，可以将前面的 Person 构造函数重写如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> job</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//创建要返回的对象</span>
  <span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">//可以在这里定义私有变量和函数</span>

  <span class="token comment">//添加方法</span>
  o<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment">//返回对象</span>
  <span class="token keyword">return</span> o<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>注意，在以这种模式创建的对象中，除了使用 sayName()方法之外，没有其他办法访问 name 的值。</li></ul> <p><strong><em>3. 使用</em></strong></p> <p>可以像下面使用稳妥的 Person 构造函数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> friend <span class="token operator">=</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token string">&quot;Software Engineer&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
friend<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Nicholas&quot;</span>
</code></pre></div><ul><li>变量 friend 中保存的是一个稳妥对象，而除了调用 sayName()方法外，没有别的方式可以访问其数据成员。即使有其他代码会给这个对象添加方法或数据成员，但也不可能有别的办法访问传到<strong>构造函数中的原始数据</strong>。</li> <li>稳妥构造函数模式提供的这种安全性，使得它非常适合在某些安全执行环境——例如，ADsafe（www.adsafe.org）和 Caja（http://code.google.com/p/google-caja/）提供的环境——下使用。</li></ul> <p><strong><em>4. 缺点</em></strong></p> <p>与寄生构造函数模式类似，使用稳妥构造函数模式创建的对象与构造函数之间也没有什么关系，因此 instanceof 操作符对这种对象也没有意义。</p> <h2 id="_6-3-继承"><a href="#_6-3-继承" class="header-anchor">#</a> 6.3 继承</h2> <p><strong><em>1. 两种继承方式</em></strong></p> <p>继承是 OO 语言中的一个最为人津津乐道的概念。</p> <p>许多 OO 语言都支持两种继承方式：</p> <ol><li>接口继承：只继承方法签名</li> <li>实现继承：继承实际的方法</li></ol> <p><strong><em>2. 实现继承</em></strong></p> <p><strong>ECMAScript 只支持实现继承</strong></p> <ul><li>如前所述，<strong>由于函数没有签名</strong>，在 ECMAScript 中无法实现接口继承。</li> <li>其实现<strong>继承主要是依靠原型链</strong>来实现的。</li></ul> <h3 id="_6-3-1-原型链"><a href="#_6-3-1-原型链" class="header-anchor">#</a> 6.3.1 原型链</h3> <p><strong><em>1. 概念</em></strong></p> <p>ECMAScript 中描述了<strong>原型链</strong>的概念，并将原型链作为实现继承的主要方法。</p> <p>其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p> <p>简单回顾一下构造函数、原型和实例的关系：</p> <ul><li>构造函数 都有一个原型对象，</li> <li>原型对象 都包含一个指向构造函数的指针，（构造函数和原型对象形成闭环）</li> <li>实例 都包含一个指向原型对象的内部指针。</li></ul> <p>那么，假如我们让<strong>原型对象等于另一个类型的实例</strong>，结果会怎么样呢？</p> <p>显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念。</p> <p><strong><em>2. 基本模式</em></strong></p> <p>实现原型链有一种基本模式，其代码大致如下。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>property <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">//注意此属性为实例属性非原型对象属性（见下图）</span>
<span class="token punctuation">}</span>

<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getSuperValue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>property<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>subproperty <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//继承了SuperType</span>
<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getSubValue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subproperty<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span><span class="token function">getSuperValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
</code></pre></div><ul><li>SubType 继承了 SuperType，而继承是通过创建 SuperType 的实例，并将该实例赋给 SubType.prototype 实现的。</li> <li>实现的<strong>本质是重写原型对象，代之以一个新类型的实例</strong>。换句话说，原来存在于 SuperType 的实例中的所有属性和方法，现在也存在于 SubType.prototype 中了。</li> <li>在确立了继承关系之后，我们给 SubType.prototype 添加了一个方法，这样就在继承了 SuperType 的属性和方法的基础上又添加了一个新方法。</li></ul> <p>这个例子中的实例以及构造函数和原型之间的关系：</p> <p><img src="https://cdn.jsdelivr.net/gh/coalyer/image-store@master/blog/professionalJs/prototype_chain.png" alt="prototype_chain"></p> <ul><li>没有使用 SubType 默认提供的原型，而是给它换了一个新原型；这个新原型就是 SuperType 的实例。于是，新原型不仅具有作为一个 SuperType 的实例所拥有的全部属性和方法，而且其内部还有一个指针，指向了 SuperType 的原型。</li> <li>最终结果就是这样的：<strong>instance 指向 SubType 的原型， SubType 的原型又指向 SuperType 的原型</strong>。</li> <li><strong>getSuperValue() 方法仍然还在 SuperType.prototype 中，但 property 则位于 SubType.prototype 中</strong>。这是因为 property 是一个<strong>实例属性</strong>，而 getSuperValue()则是一个原型方法。既然 SubType.prototype 现在是 SuperType 的实例，那么 property 当然就位于该实例中了。</li> <li>此外，要注意 instance.constructor 现在指向的是 SuperType，这是因为原来 SubType.prototype 中的<strong>constructor 被重写</strong>了的缘故。（实际上，不是 SubType 的原型的 constructor 属性被重写了，而是 SubType 的原型指向了另一个对象——SuperType 的原型，而这个原型对象的 constructor 属性指向的是 SuperType。）</li></ul> <p><strong><em>3. 实现原型链的本质</em></strong></p> <p>通过实现原型链，本质上扩展了本章前面介绍的原型搜索机制。（<a href="#查找对象属性的过程">查找对象属性的过程</a>）</p> <p>读者大概还记得，当以读取模式访问一个实例属性时，首先会在实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。</p> <ul><li><p>就拿上面的例子来说，调用 instance.getSuperValue()会经历三个搜索步骤：</p></li> <li><ol><li>搜索实例；</li> <li>搜索 SubType.prototype；</li> <li>搜索 SuperType.prototype，最后一步才会找到该方法。</li></ol></li> <li><p>在找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链末端才会停下来。</p></li></ul> <p><strong><em>4. 别忘记默认的原型</em></strong></p> <p>所有引用类型默认都继承了 Object，而这个继承也是通过原型链实现的。</p> <ul><li>大家要记住，所有函数的默认原型都是 Object 的实例，因此<strong>默认原型都会包含一个内部指针，指向 Object.prototype</strong>。这也正是所有自定义类型都会继承 toString()、valueOf()等默认方法的根本原因。所以，我们说上面例子展示的原型链中还应该包括另外一个继承层次。</li></ul> <p>图为我们展示了该例子中完整的原型链。</p> <p><img src="https://cdn.jsdelivr.net/gh/coalyer/image-store@master/blog/professionalJs/prototype_chain_all.png" alt="prototype_chain_all"></p> <ul><li><strong>一句话，SubType 继承了 SuperType，而 SuperType 继承了 Object</strong>。当调用 instance.toString()时，实际上调用的是保存在 Object.prototype 中的那个方法。</li></ul> <p><strong><em>5. 确定原型和实例的关系</em></strong></p> <p>可以通过两种方式来确定原型和实例之间的关系。</p> <ol><li><p>第一种方式是使用 instanceof 操作符，只要用这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回 true。以下几行代码就说明了这一点。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">alert</span><span class="token punctuation">(</span>instance <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
<span class="token function">alert</span><span class="token punctuation">(</span>instance <span class="token keyword">instanceof</span> <span class="token class-name">SuperType</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
<span class="token function">alert</span><span class="token punctuation">(</span>instance <span class="token keyword">instanceof</span> <span class="token class-name">SubType</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
</code></pre></div><ul><li>由于原型链的关系，我们可以说 instance 是 Object、SuperType 或 SubType 中任何一个类型的实例。因此，测试这三个构造函数的结果都返回了 true。</li></ul></li> <li><p>第二种方式是使用 isPrototypeOf()方法。同样，只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型，因此 isPrototypeOf()方法也会返回 true，如下所示。</p></li></ol> <ul><li><div class="language-js extra-class"><pre class="language-js"><code><span class="token function">alert</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
</code></pre></div></li></ul> <p><strong><em>6. 谨慎地定义方法</em></strong></p> <p><strong>子类型</strong>有时候需要重写<strong>超类型</strong>中的某个方法，或者需要添加超类型中不存在的某个方法。但<strong>不管怎样，给原型添加方法的代码一定要放在替换原型的语句之后</strong>。来看下面的例子。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>property <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getSuperValue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>property<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>subproperty <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//继承了SuperType</span>
<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//使用字面量添加新方法，会导致上一行代码无效</span>
<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">getSubValue</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subproperty<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function-variable function">someOtherMethod</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span><span class="token function">getSuperValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//error!</span>
</code></pre></div><ul><li>加粗的部分是两个方法的定义。第一个方法 getSubValue()被添加到了 SubType 中。第二个方法 getSuperValue()是原型链中已经存在的一个方法，但重写这个方法将会屏蔽原来的那个方法。换句话说，当通过 SubType 的实例调用 getSuperValue()时，调用的就是这个重新定义的方法；</li> <li>但通过 SuperType 的实例调用 getSuperValue()时，还会继续调用原来的那个方法。</li> <li>这里要格外注意的是，必须在用 SuperType 的实例替换原型之后，再定义这两个方法。</li></ul> <p>还有一点需要提醒读者，即在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这样做就会重写原型链，如下面的例子所示。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>property <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getSuperValue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>property<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>subproperty <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//继承了SuperType</span>
<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//添加新方法</span>
<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getSubValue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subproperty<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//重写超类型中的方法</span>
<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getSuperValue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span><span class="token function">getSuperValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//false</span>
</code></pre></div><ul><li><strong>由于现在的原型包含的是一个 Object 的实例，而非 SuperType 的实例</strong>，因此我们设想中的原型链已经被切断——SubType 和 SuperType 之间已经没有关系了。</li></ul> <p><strong><em>7. 原型链的问题</em></strong></p> <p>原型链虽然很强大，可以用它来实现继承，但它也存在一些问题。</p> <ol><li><p>其中，最主要的问题来自包含引用类型值的原型。</p> <ul><li><p>想必大家还记得，我们前面介绍过包含<strong>引用类型值</strong>的原型属性会被所有实例共享；而这也<strong>正是为什么要在构造函数中，而不是在原型对象中定义属性的原因</strong>。</p></li> <li><p><strong>在通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了</strong>。</p></li> <li><p>下列代码可以用来说明这个问题。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;red&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;blue&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;green&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">//继承了SuperType</span>
<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
instance1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;black&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>instance1<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;red,blue,green,black&quot;</span>

<span class="token keyword">var</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>instance2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;red,blue,green,black&quot;</span>
</code></pre></div></li> <li><p>SubType 通过原型链继承了 SuperType 之后，SubType.prototype 就变成了 SuperType 的一个实例，因此它也拥有了一个它自己的 colors 属性——<strong>就跟专门创建了一个 SubType.prototype.colors 属性一样</strong>。</p></li> <li><p>结果是 SubType 的所有实例都会共享这一个 colors 属性。而我们对 instance1.colors 的修改能够通过 instance2.colors 反映出来，就已经充分证实了这一点。</p></li></ul></li> <li><p>原型链的第二个问题是：在创建子类型的实例时，不能向超类型的构造函数中传递参数。</p></li></ol> <ul><li><ul><li>实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。</li></ul></li></ul> <p>有鉴于此，再加上前面刚刚讨论过的由于原型中包含引用类型值所带来的问题，<strong>实践中很少会单独使用原型链</strong>。</p> <h3 id="_6-3-2-借用构造函数"><a href="#_6-3-2-借用构造函数" class="header-anchor">#</a> 6.3.2 借用构造函数</h3> <p><strong><em>1. 借用构造函数</em></strong></p> <p>在解决原型中包含引用类型值所带来问题的过程中，开发人员开始使用一种叫做<strong>借用构造函数</strong>（constructor stealing）的技术（有时候也叫做<strong>伪造对象</strong>或<strong>经典继承</strong>）。</p> <ul><li>这种技术的基本思想相当简单，即<strong>在子类型构造函数的内部调用超类型构造函数</strong>。</li> <li>别忘了，<strong>函数</strong>只不过是在特定环境中执行代码的<strong>对象</strong>，<strong>因此通过使用 apply()和 call()方法也可以在（将来）新创建的对象上执行构造函数</strong></li></ul> <p>代码如下所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;red&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;blue&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;green&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//继承了SuperType</span>
  <span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
instance1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;black&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>instance1<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;red,blue,green,black&quot;</span>

<span class="token keyword">var</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>instance2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;red,blue,green&quot;</span>
</code></pre></div><ul><li>代码中加粗的那一行代码“借调”了超类型的构造函数。</li> <li>通过使用 call()方法（或 apply()方法也可以），我们实际上是在（未来将要）新创建的 SubType 实例的环境下调用了 SuperType 构造函数。</li> <li>这样一来，就会在新 SubType 对象上执行 SuperType()函数中定义的所有对象初始化代码。结果，SubType 的每个实例就都会具有自己的 colors 属性的副本了。</li></ul> <p><strong><em>2. 借用构造函数优势：传递参数</em></strong></p> <p>相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。</p> <p>看下面这个例子。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//继承了SuperType，同时还传递了参数</span>
  <span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">//实例属性</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">29</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Nicholas&quot;;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//29</span>
</code></pre></div><ul><li>SuperType 只接受一个参数 name，该参数会直接赋给一个属性。在 SubType 构造函数内部调用 SuperType 构造函数时，实际上是为 SubType 的实例设置了 name 属性。</li> <li>为了确保 SuperType 构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再添加应该在子类型中定义的属性。</li></ul> <p><strong><em>3. 借用构造函数的问题</em></strong></p> <ul><li>方法都在构造函数中定义，因此函数复用就无从谈起了。</li> <li>在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。</li> <li>考虑到这些问题，借用构造函数的技术也是很少单独使用的。</li></ul> <h3 id="_6-3-3-组合继承"><a href="#_6-3-3-组合继承" class="header-anchor">#</a> 6.3.3 组合继承</h3> <p><strong><em>1. 组合继承</em></strong></p> <p>组合继承（combination inheritance），有时候也叫做<strong>伪经典继承</strong>：</p> <ul><li>指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。</li> <li>其背后的思路是<strong>使用原型链实现对原型属性和方法的继承</strong>，而通<strong>过借用构造函数来实现对实例属性的继承</strong>。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。</li></ul> <p>下面来看一个例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;red&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;blue&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;green&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//继承属性</span>
  <span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//继承方法</span>
<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> SubType<span class="token punctuation">;</span>
<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayAge</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
instance1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;black&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>instance1<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;red,blue,green,black&quot;</span>
instance1<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Nicholas&quot;;</span>
instance1<span class="token punctuation">.</span><span class="token function">sayAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//29</span>

<span class="token keyword">var</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token string">&quot;Greg&quot;</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>instance2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;red,blue,green&quot;</span>
instance2<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Greg&quot;;</span>
instance2<span class="token punctuation">.</span><span class="token function">sayAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//27</span>
</code></pre></div><ul><li>SuperType 构造函数定义了两个属性：name 和 colors。SuperType 的原型定义了一个方法 sayName()。</li> <li>SubType 构造函数在调用 SuperType 构造函数时传入了 name 参数，紧接着又定义了它自己的属性 age。然后，将 SuperType 的实例赋值给 SubType 的原型，然后又在该新原型上定义了方法 sayAge()。</li> <li>这样一来，就可以让两个不同的 SubType 实例既分别拥有自己属性——包括 colors 属性，又可以使用相同的方法（sayName、sayAge）了。</li></ul> <p><strong><em>2. 优势</em></strong></p> <ul><li>组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，<strong>成为 JavaScript 中最常用的继承模式</strong>。</li> <li>而且，instanceof 和 isPrototypeOf()也能够用于识别基于组合继承创建的对象。</li></ul> <h3 id="_6-3-4-原型式继承"><a href="#_6-3-4-原型式继承" class="header-anchor">#</a> 6.3.4 原型式继承</h3> <p><strong><em>1. 原型式继承</em></strong></p> <p>道格拉斯·克罗克福德在 2006 年写了一篇文章，题为 Prototypal Inheritance in JavaScript （JavaScript 中的原型式继承）。</p> <ul><li><p>在这篇文章中，他介绍了一种实现继承的方法，这种方法并没有使用严格意义上的构造函数。</p></li> <li><p>他的想法是<strong>借助原型</strong>可以基于已有的对象<strong>创建新对象</strong>，同时还不必因此创建自定义类型。为了达到这个目的，他给出了如下函数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">object</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>在 object()函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。</li> <li><strong>从本质上讲，object()对传入其中的对象执行了一次浅复制</strong>。</li></ul></li></ul> <p>来看下面的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">,</span>
  friends<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;Shelby&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Court&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Van&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> anotherPerson <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
anotherPerson<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Greg&quot;</span><span class="token punctuation">;</span>
anotherPerson<span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;Rob&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> yetAnotherPerson <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
yetAnotherPerson<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Linda&quot;</span><span class="token punctuation">;</span>
yetAnotherPerson<span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;Barbie&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Shelby,Court,Van,Rob,Barbie&quot;</span>
</code></pre></div><ul><li>克罗克福德主张的这种原型式继承，要求你<strong>必须有一个对象可以作为另一个对象的基础</strong>。如果有这么一个对象的话，可以把它传递给 object()函数，然后再根据具体需求对得到的对象加以修改即可。在这个例子中，可以作为另一个对象基础的是 person 对象，于是我们把它传入到 object()函数中，然后该函数就会返回一个新对象。</li> <li>这个新对象将 person 作为原型，所以它的原型中就包含一个基本类型值属性和一个引用类型值属性。这意味着 person.friends 不仅属于 person 所有，而且也会被 anotherPerson 以及 yetAnotherPerson 共享。</li> <li>实际上，这就相当于又创建了 person 对象的两个副本。</li></ul> <p><strong><em>2. 规范化原型式继承</em></strong></p> <p>ECMAScript 5 通过新增 Object.create()方法<strong>规范化了原型式继承</strong>。</p> <ul><li><p>这个方法接收两个参数：</p> <ul><li>一个用作新对象原型的对象</li> <li>一个为新对象定义额外属性的对象（可选的）</li></ul></li> <li><p>在传入一个参数的情况下，Object.create()与 object()方法的行为相同。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">,</span>
  friends<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;Shelby&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Court&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Van&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> anotherPerson <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
anotherPerson<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Greg&quot;</span><span class="token punctuation">;</span>
anotherPerson<span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;Rob&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> yetAnotherPerson <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
yetAnotherPerson<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Linda&quot;</span><span class="token punctuation">;</span>
yetAnotherPerson<span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;Barbie&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Shelby,Court,Van,Rob,Barbie&quot;</span>
</code></pre></div></li> <li><p>第二个参数与 Object.defineProperties()方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。例如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">,</span>
  friends<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;Shelby&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Court&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Van&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> anotherPerson <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token punctuation">{</span>
    value<span class="token operator">:</span> <span class="token string">&quot;Greg&quot;</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">alert</span><span class="token punctuation">(</span>anotherPerson<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Greg&quot;</span>
</code></pre></div></li></ul> <p>支持 Object.create()方法的浏览器有 IE9+、Firefox 4+、Safari 5+、Opera 12+和 Chrome。</p> <p><strong><em>3. 使用场景和缺点</em></strong></p> <p>在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的。</p> <p>不过别忘了，包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样。</p> <h3 id="_6-3-5-寄生式继承"><a href="#_6-3-5-寄生式继承" class="header-anchor">#</a> 6.3.5 寄生式继承</h3> <p><strong><em>1. 寄生式继承</em></strong></p> <p>寄生式（parasitic）继承是与原型式继承紧密相关的一种思路，并且同样也是由克罗克福德推而广之的。</p> <ul><li>寄生式继承的思路与寄生构造函数和<strong>工厂模式类似</strong>，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。</li></ul> <p>以下代码示范了寄生式继承模式：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createAnother</span><span class="token punctuation">(</span><span class="token parameter">original</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> clone <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//通过调用函数创建一个新对象</span>
  clone<span class="token punctuation">.</span><span class="token function-variable function">sayHi</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//以某种方式来增强这个对象</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;hi&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> clone<span class="token punctuation">;</span> <span class="token comment">//返回这个对象</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><p>在这个例子中，createAnother()函数接收了一个参数，也就是将要作为新对象基础的对象。然后，把这个对象（original）传递给 object()函数，将返回的结果赋值给 clone。再为 clone 对象添加一个新方法 sayHi()，最后返回 clone 对象。</p></li> <li><p>可以像下面这样来使用 createAnother()函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">,</span>
  friends<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;Shelby&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Court&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Van&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> anotherPerson <span class="token operator">=</span> <span class="token function">createAnother</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>
anotherPerson<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;hi&quot;</span>
</code></pre></div><ul><li>这个例子中的代码基于 person 返回了一个新对象——anotherPerson。</li> <li>新对象不仅具有 person 的所有属性和方法，而且还有自己的 sayHi()方法。</li></ul></li></ul> <p><strong><em>2. 使用场景和缺点</em></strong></p> <p><strong>在主要考虑对象而不是自定义类型和构造函数的情况下</strong>，寄生式继承也是一种有用的模式。</p> <p>前面示范继承模式时使用的 object()函数不是必需的；任何能够返回新对象的函数都适用于此模式。</p> <p>使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率；这一点与构造函数模式类似。</p> <h3 id="_6-3-6-寄生组合式继承"><a href="#_6-3-6-寄生组合式继承" class="header-anchor">#</a> 6.3.6 寄生组合式继承</h3> <p><strong><em>1. 组合继承的不足</em></strong></p> <p>前面说过，组合继承是 JavaScript 最常用的继承模式；不过，它也有自己的不足。</p> <ul><li>组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。没错，子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子类型构造函数时重写这些属性。</li></ul> <p>再来看一看下面组合继承的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;red&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;blue&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;green&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//第二次调用SuperType()</span>

  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//第一次调用SuperType()</span>
<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> SubType<span class="token punctuation">;</span>
<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayAge</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>第一次调用 SuperType 构造函数时，SubType.prototype 会得到两个属性：name 和 colors；它们都是 SuperType 的实例属性，只不过现在位于 SubType 的原型中。</li> <li>当调用 SubType 构造函数时，又会调用一次 SuperType 构造函数，这一次又在新对象上创建了实例属性 name 和 colors。</li> <li>于是，这两个属性就屏蔽了原型中的两个同名属性。</li></ul> <p>图展示了上述过程：</p> <p><img src="https://cdn.jsdelivr.net/gh/coalyer/image-store@master/blog/professionalJs/combination_inheritance.png" alt="combination_inheritance"></p> <ul><li>有两组 name 和 colors 属性：一组在实例上，一组在 SubType 原型中。</li> <li>这就是调用两次 SuperType 构造函数的结果。好在我们已经找到了解决这个问题方法——寄生组合式继承。</li></ul> <p><strong><em>2. 寄生组合式继承</em></strong></p> <p>所谓寄生组合式继承，即通过借用<strong>构造函数来继承属性</strong>，通过<strong>原型链的混成形式来继承方法</strong>。</p> <ul><li>其背后的基本思路是：<strong>不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已</strong>。</li> <li>本质上，就是使用<strong>寄生式继承</strong>来继承<strong>超类型的原型</strong>，然后再将结果指定给子类型的原型。</li></ul> <p>寄生组合式继承的基本模式如下所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">inheritPrototype</span><span class="token punctuation">(</span><span class="token parameter">subType<span class="token punctuation">,</span> superType</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> prototype <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>superType<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//创建对象</span>
  prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> subType<span class="token punctuation">;</span> <span class="token comment">//增强对象</span>
  subType<span class="token punctuation">.</span>prototype <span class="token operator">=</span> prototype<span class="token punctuation">;</span> <span class="token comment">//指定对象</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><p>inheritPrototype()函数实现了寄生组合式继承的最简单形式。这个函数接收两个参数：</p> <ul><li>子类型构造函数</li> <li>超类型构造函数</li></ul></li> <li><p>在函数内部</p> <ul><li>第一步是<strong>创建超类型原型的一个副本</strong>。</li> <li>第二步是为创建的副本添加 constructor 属性，从而弥补因重写原型而失去的默认的 constructor 属性。</li> <li>最后一步，将新创建的对象（即副本）赋值给子类型的原型。</li></ul></li> <li><p>这样，我们就可以用调用 inheritPrototype()函数的语句，去替换前面例子中为子类型原型赋值的语句了，例如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;red&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;blue&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;green&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">inheritPrototype</span><span class="token punctuation">(</span>SubType<span class="token punctuation">,</span> SuperType<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayAge</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>这个例子的高效率体现在它只调用了一次 SuperType 构造函数，并且因此避免了在 SubType.prototype 上面创建不必要的、多余的属性。</li> <li>与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf()。</li></ul></li></ul> <p>开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p> <p>YUI 的 YAHOO.lang.extend()方法采用了寄生组合继承，从而让这种模式首次出现在了一个应用非常广泛的 JavaScript 库中。要了解有关 YUI 的更多信息，请访问http://developer. yahoo.com/yui/。</p> <h2 id="_6-4-小结"><a href="#_6-4-小结" class="header-anchor">#</a> 6.4 小结</h2> <p><strong><em>1. 不使用类或者接口创建对象</em></strong></p> <p>ECMAScript 支持面向对象（OO）编程，但<strong>不使用类或者接口</strong>。对象可以在代码执行过程中创建和增强，因此具有动态性而非严格定义的实体。<strong>在没有类的情况下，可以采用下列模式创建对象</strong>。</p> <ul><li>工厂模式，使用简单的函数创建对象，为对象添加属性和方法，然后返回对象。这个模式后来被构造函数模式所取代。</li> <li>构造函数模式，可以创建自定义引用类型，可以像创建内置对象实例一样使用 new 操作符。不过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。由于函数可以不局限于任何对象（即与对象具有松散耦合的特点），因此没有理由不在多个对象间共享函数。</li> <li>原型模式，使用构造函数的 prototype 属性来指定那些应该共享的属性和方法。组合使用构造函数模式和原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。</li></ul> <p><strong><em>2. 通过原型链实现继承</em></strong></p> <p>JavaScript 主要通过原型链实现继承。</p> <ul><li><p>原型链的构建是通过将一个类型的实例赋值给另一个构造函数的原型实现的。这样，<strong>子类型就能够访问超类型的所有属性和方法，这一点与基于类的继承很相似</strong>。</p></li> <li><p>原型链的问题是对象实例共享所有继承的属性和方法，因此不适宜单独使用。</p></li> <li><ul><li>解决这个问题的技术是借用构造函数，即在子类型构造函数的内部调用超类型构造函数。这样就可以做到每个实例都具有自己的属性，同时还能保证只使用构造函数模式来定义类型。</li> <li>使用最多的继承模式是组合继承，这种模式使用原型链继承共享的属性和方法，而通过借用构造函数继承实例属性。</li></ul></li></ul> <p><strong><em>3. 其他继承模式</em></strong></p> <p>此外，还存在下列可供选择的继承模式。</p> <ul><li>原型式继承，可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅复制。而复制得到的副本还可以得到进一步改造。</li> <li>寄生式继承，与原型式继承非常相似，也是基于某个对象或某些信息创建一个对象，然后增强对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合继承一起使用。</li> <li>寄生组合式继承，集寄生式继承和组合继承的优点与一身，是实现基于类型继承的最有效方式。</li></ul></div></div> <!----> <div class="page-edit"><!----> <!----> <!----></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/a7e35f/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">第5章 引用类型</div></a> <a href="/pages/0e90f4/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">第7章 函数表达式</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/a7e35f/" class="prev">第5章 引用类型</a></span> <span class="next"><a href="/pages/0e90f4/">第7章 函数表达式</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/1c4e14/"><div>你想知道的css hack知识全都帮你整理好了</div></a> <span>06-08</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/d8a080/"><div>问题和经验</div></a> <span>06-08</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/a93118/"><div>CSS Hack</div></a> <span>06-08</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:894072666@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/xugaoyi" title="GitHub" target="_blank" class="iconfont icon-github"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2021
    <span>Evan Xu | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.40794b05.js" defer></script><script src="/assets/js/2.21c2c3d2.js" defer></script><script src="/assets/js/182.e1193960.js" defer></script>
  </body>
</html>